/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NanoBananaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/settingsData.ts
var DEFAULT_SETTINGS = {
  // API Keys
  googleApiKey: "",
  openaiApiKey: "",
  anthropicApiKey: "",
  xaiApiKey: "",
  // Prompt Generation
  selectedProvider: "google",
  promptModel: "gemini-2.0-flash",
  // Image Generation
  imageModel: "gemini-3-pro-image-preview",
  imageStyle: "infographic",
  imageSize: "4K",
  preferredLanguage: "ko",
  cartoonCuts: "4",
  customCartoonCuts: 4,
  // UX Settings
  showPreviewBeforeGeneration: true,
  attachmentFolder: "999-Attachments",
  autoRetryCount: 2,
  showProgressModal: true,
  // Advanced
  customPromptPrefix: ""
};
var SYSTEM_PROMPT = `You are an expert visual designer specializing in creating image generation prompts for AI art models.

YOUR TASK: Analyze the user's content and create a detailed, specific image generation prompt for a knowledge poster/infographic.

CRITICAL REQUIREMENTS:
- Output ONLY the image prompt itself - no explanations, no introductions, no "Here's a prompt:" phrases
- Start directly with the visual description
- Be extremely specific about visual elements, colors, layout, and composition
- Focus on concrete visual descriptions that an image AI can render

PROMPT STRUCTURE TO FOLLOW:
1. Overall scene/format description (e.g., "A modern infographic poster with...")
2. Main visual elements and their arrangement
3. Color palette (specific colors like "deep navy blue #1a365d, coral orange #ff6b6b")
4. Typography style (e.g., "bold sans-serif headers, clean body text")
5. Icons, illustrations, or visual metaphors to use
6. Layout structure (grid, flow, hierarchy)
7. Mood and aesthetic (e.g., "professional, minimalist, tech-inspired")

EXAMPLE OUTPUT FORMAT:
"A sleek, modern infographic poster featuring [main topic] with a clean white background. The layout uses a vertical flow with a bold navy blue header containing the title in white sans-serif typography. Three main sections are arranged in colorful rounded cards (coral, teal, amber) with minimalist line icons. Visual metaphors include [specific icons/illustrations]. The bottom section features a summary callout box with key takeaways. Professional, educational aesthetic with high contrast and clear visual hierarchy."

Remember: Generate ONLY the prompt text, starting immediately with the visual description.`;
var IMAGE_GENERATION_PROMPT_TEMPLATE = `Create a stunning, professional knowledge poster/infographic with the following specifications:

STYLE: {style}

CONTENT TO VISUALIZE:
{prompt}

Design requirements:
- Modern, clean aesthetic with professional typography
- Clear visual hierarchy with main title, subtopics, and details
- Use icons and visual metaphors to represent concepts
- Include subtle decorative elements that enhance readability
- Color palette should be harmonious and professional
- Layout should guide the eye through the information
- Text should be minimal but impactful
- Include visual representations of data/concepts where applicable
- Make it suitable for educational/professional use
- Ensure high contrast for readability`;

// src/settings.ts
var import_obsidian = require("obsidian");

// src/types.ts
var GenerationErrorClass = class extends Error {
  constructor(type, message, retryable = false, details) {
    super(message);
    this.name = "GenerationError";
    this.type = type;
    this.details = details;
    this.retryable = retryable;
  }
};
var PROVIDER_CONFIGS = {
  openai: {
    name: "OpenAI",
    endpoint: "https://api.openai.com/v1/chat/completions",
    defaultModel: "gpt-4o",
    models: ["gpt-4o", "gpt-4o-mini", "gpt-4-turbo", "gpt-3.5-turbo"]
  },
  google: {
    name: "Google Gemini",
    endpoint: "https://generativelanguage.googleapis.com/v1beta/models",
    defaultModel: "gemini-2.0-flash",
    models: ["gemini-2.0-flash", "gemini-2.5-flash", "gemini-2.0-flash-exp", "gemini-1.5-pro", "gemini-1.5-flash"]
  },
  anthropic: {
    name: "Anthropic",
    endpoint: "https://api.anthropic.com/v1/messages",
    defaultModel: "claude-sonnet-4-20250514",
    models: ["claude-sonnet-4-20250514", "claude-3-5-sonnet-20241022", "claude-3-haiku-20240307"]
  },
  xai: {
    name: "xAI",
    endpoint: "https://api.x.ai/v1/chat/completions",
    defaultModel: "grok-4-1-fast",
    models: ["grok-4-1-fast", "grok-4-1-fast-reasoning", "grok-4-1-fast-non-reasoning", "grok-beta", "grok-2-latest"]
  }
};
var IMAGE_STYLES = {
  infographic: "Modern infographic with icons, charts, and visual hierarchy",
  poster: "Bold poster design with strong typography and imagery",
  diagram: "Technical diagram with clear connections and labels",
  mindmap: "Mind map style with central concept and branches",
  timeline: "Timeline format showing progression and milestones",
  cartoon: "Comic strip style with sequential panels telling a visual story"
};

// src/settings.ts
var NanoBananaSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("API keys").setHeading();
    new import_obsidian.Setting(containerEl).setName("Google API key").setDesc("Required for image generation. Get your key from Google AI Studio.").addText(
      (text) => text.setPlaceholder("Enter your Google API key").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
        this.plugin.settings.googleApiKey = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("external-link").setTooltip("Get API key").onClick(() => {
        window.open("https://aistudio.google.com/apikey");
      })
    );
    new import_obsidian.Setting(containerEl).setName("OpenAI API key").setDesc("Optional. Used for prompt generation if OpenAI is selected.").addText(
      (text) => text.setPlaceholder("Enter your OpenAI API key").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("external-link").setTooltip("Get API key").onClick(() => {
        window.open("https://platform.openai.com/api-keys");
      })
    );
    new import_obsidian.Setting(containerEl).setName("Anthropic API key").setDesc("Optional. Used for prompt generation if Anthropic is selected.").addText(
      (text) => text.setPlaceholder("Enter your Anthropic API key").setValue(this.plugin.settings.anthropicApiKey).onChange(async (value) => {
        this.plugin.settings.anthropicApiKey = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("external-link").setTooltip("Get API key").onClick(() => {
        window.open("https://console.anthropic.com/settings/keys");
      })
    );
    new import_obsidian.Setting(containerEl).setName("xAI API key").setDesc("Optional. Used for prompt generation if xAI is selected.").addText(
      (text) => text.setPlaceholder("Enter your xAI API key").setValue(this.plugin.settings.xaiApiKey).onChange(async (value) => {
        this.plugin.settings.xaiApiKey = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("external-link").setTooltip("Get API key").onClick(() => {
        window.open("https://console.x.ai/");
      })
    );
    new import_obsidian.Setting(containerEl).setName("Prompt generation").setHeading();
    new import_obsidian.Setting(containerEl).setName("AI provider").setDesc("Select which AI provider to use for generating image prompts.").addDropdown(
      (dropdown) => dropdown.addOptions({
        "google": "Google Gemini",
        "openai": "OpenAI",
        "anthropic": "Anthropic",
        "xai": "xAI (Grok)"
      }).setValue(this.plugin.settings.selectedProvider).onChange(async (value) => {
        this.plugin.settings.selectedProvider = value;
        this.plugin.settings.promptModel = PROVIDER_CONFIGS[value].defaultModel;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    const providerConfig = PROVIDER_CONFIGS[this.plugin.settings.selectedProvider];
    new import_obsidian.Setting(containerEl).setName("Prompt model").setDesc(`Model to use for prompt generation. Suggestions: ${providerConfig.models.join(", ")}`).addText(
      (text) => text.setPlaceholder(providerConfig.defaultModel).setValue(this.plugin.settings.promptModel).onChange(async (value) => {
        this.plugin.settings.promptModel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Image generation").setHeading();
    new import_obsidian.Setting(containerEl).setName("Image model").setDesc("Google Gemini model for image generation. Must support image output.").addText(
      (text) => text.setPlaceholder("gemini-3-pro-image-preview").setValue(this.plugin.settings.imageModel).onChange(async (value) => {
        this.plugin.settings.imageModel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Image style").setDesc("Default style for generated posters.").addDropdown(
      (dropdown) => dropdown.addOptions({
        "infographic": "\u{1F4CA} infographic - charts, icons, visual hierarchy",
        "poster": "\u{1F3A8} poster - bold typography, strong imagery",
        "diagram": "\u{1F4D0} diagram - technical, clear connections",
        "mindmap": "\u{1F9E0} mind map - central concept with branches",
        "timeline": "\u{1F4C5} timeline - progression and milestones",
        "cartoon": "\u{1F3AC} cartoon - comic strip with sequential panels"
      }).setValue(this.plugin.settings.imageStyle).onChange(async (value) => {
        this.plugin.settings.imageStyle = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.imageStyle === "cartoon") {
      new import_obsidian.Setting(containerEl).setName("Cartoon panel cuts").setDesc("Number of panels in the comic strip.").addDropdown(
        (dropdown) => dropdown.addOptions({
          "4": "4 cuts (2\xD72 grid)",
          "6": "6 cuts (2\xD73 grid)",
          "8": "8 cuts (2\xD74 grid)",
          "custom": "custom number"
        }).setValue(this.plugin.settings.cartoonCuts).onChange(async (value) => {
          this.plugin.settings.cartoonCuts = value;
          await this.plugin.saveSettings();
          this.display();
        })
      );
      if (this.plugin.settings.cartoonCuts === "custom") {
        new import_obsidian.Setting(containerEl).setName("Custom panel count").setDesc("Enter a custom number of panels (2-12 recommended).").addText(
          (text) => text.setPlaceholder("4").setValue(String(this.plugin.settings.customCartoonCuts)).onChange(async (value) => {
            const numValue = parseInt(value) || 4;
            this.plugin.settings.customCartoonCuts = Math.max(2, Math.min(12, numValue));
            await this.plugin.saveSettings();
          })
        );
      }
    }
    new import_obsidian.Setting(containerEl).setName("Image resolution").setDesc("Higher resolution = better quality (especially for Korean text). 4K recommended for best results.").addDropdown(
      (dropdown) => dropdown.addOptions({
        "1K": "1K - standard quality",
        "2K": "2K - high quality",
        "4K": "4K - ultra HD quality (recommended) \u2B50"
      }).setValue(this.plugin.settings.imageSize).onChange(async (value) => {
        this.plugin.settings.imageSize = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Preferred language").setDesc("Language for text in generated images (e.g., titles, labels, descriptions).").addDropdown(
      (dropdown) => dropdown.addOptions({
        "ko": "\u{1F1F0}\u{1F1F7} \uD55C\uAD6D\uC5B4 (Korean)",
        "en": "\u{1F1FA}\u{1F1F8} English",
        "ja": "\u{1F1EF}\u{1F1F5} \u65E5\u672C\u8A9E (Japanese)",
        "zh": "\u{1F1E8}\u{1F1F3} \u4E2D\u6587 (Chinese)",
        "es": "\u{1F1EA}\u{1F1F8} Espa\xF1ol (Spanish)",
        "fr": "\u{1F1EB}\u{1F1F7} Fran\xE7ais (French)",
        "de": "\u{1F1E9}\u{1F1EA} Deutsch (German)"
      }).setValue(this.plugin.settings.preferredLanguage).onChange(async (value) => {
        this.plugin.settings.preferredLanguage = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("User experience").setHeading();
    new import_obsidian.Setting(containerEl).setName("Show preview before generation").setDesc("Show the generated prompt and allow editing before creating the image.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showPreviewBeforeGeneration).onChange(async (value) => {
        this.plugin.settings.showPreviewBeforeGeneration = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show progress modal").setDesc("Display a progress indicator during generation.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showProgressModal).onChange(async (value) => {
        this.plugin.settings.showProgressModal = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Attachment folder").setDesc("Folder to save generated images. Will be created if it doesn't exist.").addText(
      (text) => text.setPlaceholder("999-Attachments").setValue(this.plugin.settings.attachmentFolder).onChange(async (value) => {
        this.plugin.settings.attachmentFolder = value || "999-Attachments";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto-retry count").setDesc("Number of automatic retries on transient failures (0-5).").addSlider(
      (slider) => slider.setLimits(0, 5, 1).setValue(this.plugin.settings.autoRetryCount).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.autoRetryCount = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Advanced").setHeading();
    new import_obsidian.Setting(containerEl).setName("Custom prompt prefix").setDesc("Optional text to prepend to all generated prompts.").addTextArea(
      (textarea) => textarea.setPlaceholder('e.g., "Create in a minimalist style with blue color scheme..."').setValue(this.plugin.settings.customPromptPrefix).onChange(async (value) => {
        this.plugin.settings.customPromptPrefix = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("About").setHeading();
    const aboutDiv = containerEl.createDiv({ cls: "nanobanana-about" });
    aboutDiv.createEl("p", {
      text: "NanoBanana PRO v1.0.0"
    });
    aboutDiv.createEl("p", {
      text: "Generate beautiful knowledge posters from your notes using AI."
    });
    const linksDiv = aboutDiv.createDiv({ cls: "nanobanana-links" });
    linksDiv.createEl("a", {
      text: "\u{1F4D6} documentation",
      href: "https://github.com/username/nanobanana-pro-obsidian#readme"
    });
    linksDiv.createEl("span", { text: " | " });
    linksDiv.createEl("a", {
      text: "\u{1F41B} report issue",
      href: "https://github.com/username/nanobanana-pro-obsidian/issues"
    });
  }
};

// src/services/promptService.ts
var import_obsidian2 = require("obsidian");
var PromptService = class {
  /**
   * Generate an image prompt from note content using the specified AI provider
   */
  async generatePrompt(noteContent, provider, model, apiKey) {
    if (!apiKey) {
      throw this.createError("INVALID_API_KEY", `${PROVIDER_CONFIGS[provider].name} API key is not configured`);
    }
    if (!noteContent.trim()) {
      throw this.createError("NO_CONTENT", "Note content is empty");
    }
    try {
      const prompt = await this.callProvider(provider, model, apiKey, noteContent);
      return {
        prompt,
        model,
        provider
      };
    } catch (error) {
      if (error instanceof GenerationErrorClass) {
        throw error;
      }
      throw this.handleApiError(error, provider);
    }
  }
  async callProvider(provider, model, apiKey, content) {
    switch (provider) {
      case "openai":
        return this.callOpenAI(model, apiKey, content);
      case "google":
        return this.callGoogle(model, apiKey, content);
      case "anthropic":
        return this.callAnthropic(model, apiKey, content);
      case "xai":
        return this.callXAI(model, apiKey, content);
      default: {
        const unknownProvider = provider;
        throw this.createError("UNKNOWN", `Unknown provider: ${String(unknownProvider)}`);
      }
    }
  }
  async callOpenAI(model, apiKey, content) {
    var _a, _b, _c;
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: "system", content: SYSTEM_PROMPT },
          { role: "user", content: `Create an image prompt for the following content:

${content}` }
        ],
        max_tokens: 1e3,
        temperature: 0.7
      })
    });
    if (response.status !== 200) {
      throw this.handleHttpError(response.status, response.text, "openai");
    }
    const data = response.json;
    return ((_c = (_b = (_a = data.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content) == null ? void 0 : _c.trim()) || "";
  }
  async callGoogle(model, apiKey, content) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
    const response = await (0, import_obsidian2.requestUrl)({
      url,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        // System instruction - REST API uses snake_case
        system_instruction: {
          parts: [{ text: SYSTEM_PROMPT }]
        },
        contents: [{
          role: "user",
          parts: [{
            text: `Create an image prompt for the following content:

${content}`
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 1e3
        },
        safetySettings: [
          { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
          { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
          { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
          { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
        ]
      })
    });
    if (response.status !== 200) {
      throw this.handleHttpError(response.status, response.text, "google");
    }
    const data = response.json;
    const generatedText = ((_f = (_e = (_d = (_c = (_b = (_a = data.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.text) == null ? void 0 : _f.trim()) || "";
    if (!generatedText) {
      console.error("Gemini API response:", JSON.stringify(data, null, 2));
      const safetyRatings = (_h = (_g = data.candidates) == null ? void 0 : _g[0]) == null ? void 0 : _h.safetyRatings;
      if (safetyRatings) {
        console.error("Safety Ratings:", JSON.stringify(safetyRatings, null, 2));
      }
      throw this.createError("GENERATION_FAILED", "Gemini API returned empty response. Check console for details.");
    }
    return generatedText;
  }
  async callAnthropic(model, apiKey, content) {
    var _a, _b, _c;
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": apiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model,
        max_tokens: 1e3,
        system: SYSTEM_PROMPT,
        messages: [
          { role: "user", content: `Create an image prompt for the following content:

${content}` }
        ]
      })
    });
    if (response.status !== 200) {
      throw this.handleHttpError(response.status, response.text, "anthropic");
    }
    const data = response.json;
    return ((_c = (_b = (_a = data.content) == null ? void 0 : _a[0]) == null ? void 0 : _b.text) == null ? void 0 : _c.trim()) || "";
  }
  async callXAI(model, apiKey, content) {
    var _a, _b, _c;
    console.debug("[xAI Debug] Model:", model);
    console.debug("[xAI Debug] Content length:", content.length);
    console.debug("[xAI Debug] System prompt length:", SYSTEM_PROMPT.length);
    try {
      const response = await (0, import_obsidian2.requestUrl)({
        url: "https://api.x.ai/v1/chat/completions",
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model,
          messages: [
            { role: "system", content: SYSTEM_PROMPT },
            { role: "user", content: `Create an image prompt for the following content:

${content}` }
          ],
          temperature: 0.7
        })
      });
      console.debug("[xAI Debug] Response status:", response.status);
      if (response.status !== 200) {
        console.error("[xAI Debug] Error response:", response.text);
        throw this.handleHttpError(response.status, response.text, "xai");
      }
      const data = response.json;
      console.debug("[xAI Debug] Success! Response received");
      return ((_c = (_b = (_a = data.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content) == null ? void 0 : _c.trim()) || "";
    } catch (error) {
      console.error("[xAI Debug] FULL ERROR:", error);
      console.error("[xAI Debug] Error type:", typeof error);
      console.error("[xAI Debug] Error message:", error instanceof Error ? error.message : String(error));
      console.error("[xAI Debug] Error stack:", error instanceof Error ? error.stack : "no stack");
      throw error;
    }
  }
  handleHttpError(status, responseText, provider) {
    if (status === 401 || status === 403) {
      return this.createError("INVALID_API_KEY", `Invalid ${PROVIDER_CONFIGS[provider].name} API key`);
    }
    if (status === 429) {
      return this.createError("RATE_LIMIT", "API rate limit exceeded. Please wait a few minutes and try again.", false);
    }
    if (status >= 500) {
      return this.createError("NETWORK_ERROR", "Server error. Please try again later.", true);
    }
    return this.createError("GENERATION_FAILED", `API error: ${responseText}`);
  }
  handleApiError(error, provider) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("status 429") || errorMessage.includes("429")) {
      console.warn(`${PROVIDER_CONFIGS[provider].name} rate limit detected from exception`);
      return this.createError("RATE_LIMIT", "API rate limit exceeded. Please wait a few minutes and try again.", false);
    }
    if (errorMessage.includes("status 401") || errorMessage.includes("status 403")) {
      return this.createError("INVALID_API_KEY", `Invalid ${PROVIDER_CONFIGS[provider].name} API key`);
    }
    if (errorMessage.includes("net::") || errorMessage.includes("network")) {
      return this.createError("NETWORK_ERROR", "Network connection error. Check your internet connection.", true);
    }
    return this.createError("GENERATION_FAILED", `${PROVIDER_CONFIGS[provider].name} error: ${errorMessage}`);
  }
  createError(type, message, retryable = false) {
    return new GenerationErrorClass(type, message, retryable);
  }
};

// src/services/imageService.ts
var import_obsidian3 = require("obsidian");
var ImageService = class {
  /**
   * Generate an infographic image using Google Gemini
   */
  async generateImage(prompt, apiKey, model, style, preferredLanguage, imageSize = "4K", cartoonCuts = 4) {
    if (!apiKey) {
      throw this.createError("INVALID_API_KEY", "Google API key is not configured");
    }
    if (!prompt.trim()) {
      throw this.createError("NO_CONTENT", "Prompt is empty");
    }
    try {
      const languageInstructions = {
        ko: "IMPORTANT: All text in the image MUST be in Korean (\uD55C\uAD6D\uC5B4). Titles, labels, descriptions, and all content should be written in Korean.",
        en: "IMPORTANT: All text in the image MUST be in English. Titles, labels, descriptions, and all content should be written in English.",
        ja: "IMPORTANT: All text in the image MUST be in Japanese (\u65E5\u672C\u8A9E). Titles, labels, descriptions, and all content should be written in Japanese.",
        zh: "IMPORTANT: All text in the image MUST be in Chinese (\u4E2D\u6587). Titles, labels, descriptions, and all content should be written in Chinese.",
        es: "IMPORTANT: All text in the image MUST be in Spanish (Espa\xF1ol). Titles, labels, descriptions, and all content should be written in Spanish.",
        fr: "IMPORTANT: All text in the image MUST be in French (Fran\xE7ais). Titles, labels, descriptions, and all content should be written in French.",
        de: "IMPORTANT: All text in the image MUST be in German (Deutsch). Titles, labels, descriptions, and all content should be written in German."
      };
      let styleDescription = IMAGE_STYLES[style];
      if (style === "cartoon") {
        styleDescription = this.getCartoonStyleDescription(cartoonCuts);
      }
      const fullPrompt = IMAGE_GENERATION_PROMPT_TEMPLATE.replace("{style}", styleDescription).replace("{prompt}", prompt) + "\n\n" + languageInstructions[preferredLanguage];
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      const response = await (0, import_obsidian3.requestUrl)({
        url,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: fullPrompt
            }]
          }],
          generationConfig: {
            responseModalities: ["TEXT", "IMAGE"],
            imageConfig: {
              imageSize
            }
          },
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
          ]
        })
      });
      if (response.status !== 200) {
        throw this.handleHttpError(response.status, response.text);
      }
      const data = response.json;
      const imageData = this.extractImageFromResponse(data);
      if (!imageData) {
        throw this.createError("GENERATION_FAILED", "No image was generated. Try a different prompt or style.");
      }
      return {
        imageData: imageData.data,
        mimeType: imageData.mimeType,
        model
      };
    } catch (error) {
      if (error instanceof GenerationErrorClass) {
        throw error;
      }
      throw this.handleApiError(error);
    }
  }
  /**
   * Extract base64 image data from Gemini API response
   */
  extractImageFromResponse(data) {
    var _a;
    try {
      const candidates = data.candidates;
      if (!candidates || candidates.length === 0) {
        return null;
      }
      const content = candidates[0].content;
      if (!content || !content.parts) {
        return null;
      }
      for (const part of content.parts) {
        if (part.inline_data) {
          return {
            data: part.inline_data.data,
            mimeType: part.inline_data.mime_type || "image/png"
          };
        }
      }
      if ((_a = content.parts[0]) == null ? void 0 : _a.inlineData) {
        return {
          data: content.parts[0].inlineData.data,
          mimeType: content.parts[0].inlineData.mimeType || "image/png"
        };
      }
      return null;
    } catch (e) {
      console.error("Error extracting image from response:", e);
      return null;
    }
  }
  handleHttpError(status, responseText) {
    if (status === 401 || status === 403) {
      return this.createError("INVALID_API_KEY", "Invalid Google API key");
    }
    if (status === 429) {
      return this.createError("RATE_LIMIT", "API rate limit exceeded. Please wait and try again.", true);
    }
    if (status === 400) {
      if (responseText.includes("SAFETY") || responseText.includes("blocked")) {
        return this.createError("CONTENT_FILTERED", "Content was blocked by safety filters. Try modifying your prompt.");
      }
      return this.createError("GENERATION_FAILED", `Bad request: ${responseText}`);
    }
    if (status >= 500) {
      return this.createError("NETWORK_ERROR", "Server error. Please try again later.", true);
    }
    return this.createError("GENERATION_FAILED", `API error (${status}): ${responseText}`);
  }
  handleApiError(error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("net::") || errorMessage.includes("network")) {
      return this.createError("NETWORK_ERROR", "Network connection error. Check your internet connection.", true);
    }
    return this.createError("GENERATION_FAILED", `Image generation error: ${errorMessage}`);
  }
  createError(type, message, retryable = false) {
    return new GenerationErrorClass(type, message, retryable);
  }
  /**
   * Generate cartoon style description based on number of cuts
   */
  getCartoonStyleDescription(cuts) {
    const layoutDescriptions = {
      4: "2x2 grid layout (2 rows, 2 columns)",
      6: "2x3 grid layout (2 rows, 3 columns) or 3x2 grid layout",
      8: "2x4 grid layout (2 rows, 4 columns) or 4x2 grid layout"
    };
    const layout = layoutDescriptions[cuts] || `${cuts} sequential panels in a balanced grid`;
    return `Comic strip / manga style illustration with exactly ${cuts} sequential panels arranged in a ${layout}.
Each panel should:
- Tell part of the story in clear visual sequence from panel 1 to panel ${cuts}
- Feature expressive characters with consistent design across all panels
- Include speech bubbles or thought bubbles where appropriate
- Use bold black outlines and vibrant colors
- Show dynamic compositions and varied camera angles
- Have clear panel borders with small gaps between panels
- Progress the narrative logically from beginning to end

The overall style should be:
- Modern comic/manga aesthetic with clean linework
- High contrast colors for visual impact
- Professional quality suitable for educational content
- Easy to follow visual storytelling`;
  }
};

// src/services/fileService.ts
var import_obsidian4 = require("obsidian");
var FileService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Save image to the vault and return the path
   */
  async saveImage(imageData, mimeType, noteFile, attachmentFolder) {
    try {
      const extension = this.getExtensionFromMimeType(mimeType);
      const timestamp = Date.now();
      const baseName = noteFile.basename.replace(/[^a-zA-Z0-9가-힣]/g, "-");
      const fileName = `${baseName}-poster-${timestamp}.${extension}`;
      await this.ensureFolderExists(attachmentFolder);
      const imagePath = (0, import_obsidian4.normalizePath)(`${attachmentFolder}/${fileName}`);
      const binaryData = this.base64ToArrayBuffer(imageData);
      await this.app.vault.createBinary(imagePath, binaryData);
      return imagePath;
    } catch (error) {
      throw this.createError("SAVE_ERROR", `Failed to save image: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Embed image at the top of the note
   */
  async embedImageInNote(noteFile, imagePath) {
    try {
      const content = await this.app.vault.read(noteFile);
      const embedSyntax = `![[${imagePath}]]

`;
      const frontmatterMatch = content.match(/^---\n[\s\S]*?\n---\n/);
      let newContent;
      if (frontmatterMatch) {
        const frontmatter = frontmatterMatch[0];
        const restContent = content.slice(frontmatter.length);
        const existingEmbed = restContent.match(/^!\[\[.*-poster-\d+\.(png|jpg|jpeg|webp)\]\]\n\n/);
        if (existingEmbed) {
          newContent = frontmatter + embedSyntax + restContent.slice(existingEmbed[0].length);
        } else {
          newContent = frontmatter + embedSyntax + restContent;
        }
      } else {
        const existingEmbed = content.match(/^!\[\[.*-poster-\d+\.(png|jpg|jpeg|webp)\]\]\n\n/);
        if (existingEmbed) {
          newContent = embedSyntax + content.slice(existingEmbed[0].length);
        } else {
          newContent = embedSyntax + content;
        }
      }
      await this.app.vault.modify(noteFile, newContent);
    } catch (error) {
      throw this.createError("SAVE_ERROR", `Failed to embed image: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Ensure a folder exists, creating it if necessary
   */
  async ensureFolderExists(folderPath) {
    const normalizedPath = (0, import_obsidian4.normalizePath)(folderPath);
    const folder = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (!folder) {
      await this.app.vault.createFolder(normalizedPath);
    } else if (!(folder instanceof import_obsidian4.TFolder)) {
      throw this.createError("SAVE_ERROR", `${folderPath} exists but is not a folder`);
    }
  }
  /**
   * Convert base64 string to ArrayBuffer
   */
  base64ToArrayBuffer(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
  }
  /**
   * Get file extension from MIME type
   */
  getExtensionFromMimeType(mimeType) {
    const mimeMap = {
      "image/png": "png",
      "image/jpeg": "jpg",
      "image/jpg": "jpg",
      "image/webp": "webp",
      "image/gif": "gif"
    };
    return mimeMap[mimeType] || "png";
  }
  createError(type, message) {
    return new GenerationErrorClass(type, message, false);
  }
};

// src/progressModal.ts
var import_obsidian5 = require("obsidian");

// src/i18n.ts
var MESSAGES = {
  ko: {
    // Progress Modal
    progressTitle: "\u{1F3A8} Knowledge poster \uC0DD\uC131 \uC911...",
    estimatedTime: "\u23F1\uFE0F \uC608\uC0C1 \uC18C\uC694 \uC2DC\uAC04: \uC57D 15-30\uCD08",
    cancel: "\uCDE8\uC18C",
    // Progress Steps
    stepAnalyzing: "\uB178\uD2B8 \uBD84\uC11D",
    stepGeneratingPrompt: "\uD504\uB86C\uD504\uD2B8 \uC0DD\uC131",
    stepGeneratingImage: "\uC774\uBBF8\uC9C0 \uC0DD\uC131",
    stepSaving: "\uD30C\uC77C \uC800\uC7A5",
    stepEmbedding: "\uB178\uD2B8\uC5D0 \uC0BD\uC785",
    // Success
    successTitle: "\u2705 Knowledge poster \uC0DD\uC131 \uC644\uB8CC!",
    successSaved: "\u{1F4C1} \uC800\uC7A5 \uC704\uCE58",
    confirm: "\uD655\uC778",
    // Error
    errorTitle: "\u274C \uC0DD\uC131 \uC2E4\uD328",
    errorSolutions: "\u{1F4A1} \uD574\uACB0 \uBC29\uBC95:",
    retry: "\uB2E4\uC2DC \uC2DC\uB3C4",
    close: "\uB2EB\uAE30",
    // Error Suggestions
    suggestionCheckApiKey: "\uC124\uC815\uC5D0\uC11C API \uD0A4\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694",
    suggestionVerifyApiKey: "API \uD0A4\uAC00 \uC62C\uBC14\uB974\uAC8C \uC785\uB825\uB418\uC5C8\uB294\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694",
    suggestionActivateApiKey: "\uD574\uB2F9 \uC11C\uBE44\uC2A4\uC758 API \uD0A4\uAC00 \uD65C\uC131\uD654\uB418\uC5B4 \uC788\uB294\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694",
    suggestionWaitAndRetry: "\uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694",
    suggestionCheckQuota: "API \uC0AC\uC6A9\uB7C9 \uD55C\uB3C4\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694",
    suggestionCheckInternet: "\uC778\uD130\uB137 \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694",
    suggestionCheckVPN: "VPN\uC774\uB098 \uD504\uB85D\uC2DC \uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694",
    suggestionTryDifferentStyle: "\uB2E4\uB978 \uC2A4\uD0C0\uC77C\uB85C \uC2DC\uB3C4\uD574\uBCF4\uC138\uC694",
    suggestionModifyContent: "\uB178\uD2B8 \uB0B4\uC6A9\uC744 \uC218\uC815\uD558\uACE0 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694",
    suggestionContentMayBeSensitive: "\uBBFC\uAC10\uD55C \uB0B4\uC6A9\uC774 \uD3EC\uD568\uB418\uC5B4 \uC788\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4",
    suggestionAddContent: "\uB178\uD2B8\uC5D0 \uB0B4\uC6A9\uC744 \uCD94\uAC00\uD574\uC8FC\uC138\uC694",
    // Preview Modal
    previewTitle: "\u{1F4DD} \uD504\uB86C\uD504\uD2B8 \uBBF8\uB9AC\uBCF4\uAE30",
    previewPromptLabel: "\uC0DD\uC131\uB41C \uD504\uB86C\uD504\uD2B8 (\uC218\uC815 \uAC00\uB2A5):",
    previewCharacters: "\uC790",
    previewTipsTitle: "\u{1F4A1} \uD301:",
    previewTip1: "\uD504\uB86C\uD504\uD2B8\uB97C \uC218\uC815\uD558\uC5EC \uC6D0\uD558\uB294 \uC2A4\uD0C0\uC77C\uB85C \uC870\uC815\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4",
    previewTip2: "\uAD6C\uCCB4\uC801\uC778 \uC0C9\uC0C1, \uB808\uC774\uC544\uC6C3, \uC694\uC18C\uB97C \uCD94\uAC00\uD558\uBA74 \uB354 \uC88B\uC740 \uACB0\uACFC\uB97C \uC5BB\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4",
    previewTip3: '"\uB2E4\uC2DC \uC0DD\uC131" \uBC84\uD2BC\uC73C\uB85C \uC0C8\uB85C\uC6B4 \uD504\uB86C\uD504\uD2B8\uB97C \uC0DD\uC131\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4',
    previewGenerate: "\u{1F3A8} \uC774\uBBF8\uC9C0 \uC0DD\uC131",
    previewRegenerate: "\u{1F504} \uB2E4\uC2DC \uC0DD\uC131",
    previewPromptModel: "\u{1F916} \uD504\uB86C\uD504\uD2B8 \uBAA8\uB378",
    previewImageModel: "\u{1F5BC}\uFE0F \uC774\uBBF8\uC9C0 \uBAA8\uB378",
    previewStyle: "\u{1F4CA} \uC2A4\uD0C0\uC77C"
  },
  en: {
    // Progress Modal
    progressTitle: "\u{1F3A8} generating knowledge poster...",
    estimatedTime: "\u23F1\uFE0F estimated time: about 15-30 seconds",
    cancel: "Cancel",
    // Progress Steps
    stepAnalyzing: "Analyzing note",
    stepGeneratingPrompt: "Generating prompt",
    stepGeneratingImage: "Generating image",
    stepSaving: "Saving file",
    stepEmbedding: "Embedding in note",
    // Success
    successTitle: "\u2705 knowledge poster created!",
    successSaved: "\u{1F4C1} saved to",
    confirm: "OK",
    // Error
    errorTitle: "\u274C generation failed",
    errorSolutions: "\u{1F4A1} solutions:",
    retry: "Retry",
    close: "Close",
    // Error Suggestions
    suggestionCheckApiKey: "Please check your API key in settings",
    suggestionVerifyApiKey: "Please verify that your API key is entered correctly",
    suggestionActivateApiKey: "Please ensure the API key is activated for this service",
    suggestionWaitAndRetry: "Please wait a moment and try again",
    suggestionCheckQuota: "Please check your API usage quota",
    suggestionCheckInternet: "Please check your internet connection",
    suggestionCheckVPN: "Please check your VPN or proxy settings",
    suggestionTryDifferentStyle: "Please try a different style",
    suggestionModifyContent: "Please modify the note content and try again",
    suggestionContentMayBeSensitive: "The content may contain sensitive material",
    suggestionAddContent: "Please add content to your note",
    // Preview Modal
    previewTitle: "\u{1F4DD} prompt preview",
    previewPromptLabel: "Generated prompt (editable):",
    previewCharacters: "characters",
    previewTipsTitle: "\u{1F4A1} tips:",
    previewTip1: "You can edit the prompt to adjust the desired style",
    previewTip2: "Adding specific colors, layouts, and elements will give better results",
    previewTip3: 'Use the "Regenerate" button to create a new prompt',
    previewGenerate: "\u{1F3A8} generate image",
    previewRegenerate: "\u{1F504} regenerate",
    previewPromptModel: "\u{1F916} prompt model",
    previewImageModel: "\u{1F5BC}\uFE0F image model",
    previewStyle: "\u{1F4CA} style"
  },
  ja: {
    // Progress Modal
    progressTitle: "\u{1F3A8} \u30CA\u30EC\u30C3\u30B8\u30DD\u30B9\u30BF\u30FC\u751F\u6210\u4E2D...",
    estimatedTime: "\u23F1\uFE0F \u63A8\u5B9A\u6642\u9593\uFF1A\u7D0415\u301C30\u79D2",
    cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
    // Progress Steps
    stepAnalyzing: "\u30CE\u30FC\u30C8\u5206\u6790",
    stepGeneratingPrompt: "\u30D7\u30ED\u30F3\u30D7\u30C8\u751F\u6210",
    stepGeneratingImage: "\u753B\u50CF\u751F\u6210",
    stepSaving: "\u30D5\u30A1\u30A4\u30EB\u4FDD\u5B58",
    stepEmbedding: "\u30CE\u30FC\u30C8\u306B\u633F\u5165",
    // Success
    successTitle: "\u2705 \u30CA\u30EC\u30C3\u30B8\u30DD\u30B9\u30BF\u30FC\u4F5C\u6210\u5B8C\u4E86\uFF01",
    successSaved: "\u{1F4C1} \u4FDD\u5B58\u5148",
    confirm: "OK",
    // Error
    errorTitle: "\u274C \u751F\u6210\u5931\u6557",
    errorSolutions: "\u{1F4A1} \u89E3\u6C7A\u65B9\u6CD5\uFF1A",
    retry: "\u518D\u8A66\u884C",
    close: "\u9589\u3058\u308B",
    // Error Suggestions
    suggestionCheckApiKey: "\u8A2D\u5B9A\u3067API\u30AD\u30FC\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044",
    suggestionVerifyApiKey: "API\u30AD\u30FC\u304C\u6B63\u3057\u304F\u5165\u529B\u3055\u308C\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044",
    suggestionActivateApiKey: "\u3053\u306E\u30B5\u30FC\u30D3\u30B9\u306EAPI\u30AD\u30FC\u304C\u6709\u52B9\u5316\u3055\u308C\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044",
    suggestionWaitAndRetry: "\u3057\u3070\u3089\u304F\u5F85\u3063\u3066\u304B\u3089\u518D\u5EA6\u304A\u8A66\u3057\u304F\u3060\u3055\u3044",
    suggestionCheckQuota: "API\u4F7F\u7528\u91CF\u306E\u4E0A\u9650\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044",
    suggestionCheckInternet: "\u30A4\u30F3\u30BF\u30FC\u30CD\u30C3\u30C8\u63A5\u7D9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044",
    suggestionCheckVPN: "VPN\u307E\u305F\u306F\u30D7\u30ED\u30AD\u30B7\u8A2D\u5B9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044",
    suggestionTryDifferentStyle: "\u5225\u306E\u30B9\u30BF\u30A4\u30EB\u3067\u8A66\u3057\u3066\u304F\u3060\u3055\u3044",
    suggestionModifyContent: "\u30CE\u30FC\u30C8\u306E\u5185\u5BB9\u3092\u4FEE\u6B63\u3057\u3066\u518D\u5EA6\u304A\u8A66\u3057\u304F\u3060\u3055\u3044",
    suggestionContentMayBeSensitive: "\u6A5F\u5BC6\u6027\u306E\u9AD8\u3044\u5185\u5BB9\u304C\u542B\u307E\u308C\u3066\u3044\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059",
    suggestionAddContent: "\u30CE\u30FC\u30C8\u306B\u5185\u5BB9\u3092\u8FFD\u52A0\u3057\u3066\u304F\u3060\u3055\u3044",
    // Preview Modal
    previewTitle: "\u{1F4DD} \u30D7\u30ED\u30F3\u30D7\u30C8\u30D7\u30EC\u30D3\u30E5\u30FC",
    previewPromptLabel: "\u751F\u6210\u3055\u308C\u305F\u30D7\u30ED\u30F3\u30D7\u30C8 (\u7DE8\u96C6\u53EF\u80FD):",
    previewCharacters: "\u6587\u5B57",
    previewTipsTitle: "\u{1F4A1} \u30D2\u30F3\u30C8:",
    previewTip1: "\u30D7\u30ED\u30F3\u30D7\u30C8\u3092\u7DE8\u96C6\u3057\u3066\u5E0C\u671B\u306E\u30B9\u30BF\u30A4\u30EB\u306B\u8ABF\u6574\u3067\u304D\u307E\u3059",
    previewTip2: "\u5177\u4F53\u7684\u306A\u8272\u3001\u30EC\u30A4\u30A2\u30A6\u30C8\u3001\u8981\u7D20\u3092\u8FFD\u52A0\u3059\u308B\u3068\u3001\u3088\u308A\u826F\u3044\u7D50\u679C\u304C\u5F97\u3089\u308C\u307E\u3059",
    previewTip3: "\u300C\u518D\u751F\u6210\u300D\u30DC\u30BF\u30F3\u3067\u65B0\u3057\u3044\u30D7\u30ED\u30F3\u30D7\u30C8\u3092\u751F\u6210\u3067\u304D\u307E\u3059",
    previewGenerate: "\u{1F3A8} \u753B\u50CF\u751F\u6210",
    previewRegenerate: "\u{1F504} \u518D\u751F\u6210",
    previewPromptModel: "\u{1F916} \u30D7\u30ED\u30F3\u30D7\u30C8\u30E2\u30C7\u30EB",
    previewImageModel: "\u{1F5BC}\uFE0F \u753B\u50CF\u30E2\u30C7\u30EB",
    previewStyle: "\u{1F4CA} \u30B9\u30BF\u30A4\u30EB"
  },
  zh: {
    // Progress Modal
    progressTitle: "\u{1F3A8} \u6B63\u5728\u751F\u6210\u77E5\u8BC6\u6D77\u62A5...",
    estimatedTime: "\u23F1\uFE0F \u9884\u8BA1\u65F6\u95F4\uFF1A\u7EA615-30\u79D2",
    cancel: "\u53D6\u6D88",
    // Progress Steps
    stepAnalyzing: "\u5206\u6790\u7B14\u8BB0",
    stepGeneratingPrompt: "\u751F\u6210\u63D0\u793A\u8BCD",
    stepGeneratingImage: "\u751F\u6210\u56FE\u7247",
    stepSaving: "\u4FDD\u5B58\u6587\u4EF6",
    stepEmbedding: "\u63D2\u5165\u7B14\u8BB0",
    // Success
    successTitle: "\u2705 \u77E5\u8BC6\u6D77\u62A5\u521B\u5EFA\u5B8C\u6210\uFF01",
    successSaved: "\u{1F4C1} \u4FDD\u5B58\u4F4D\u7F6E",
    confirm: "\u786E\u8BA4",
    // Error
    errorTitle: "\u274C \u751F\u6210\u5931\u8D25",
    errorSolutions: "\u{1F4A1} \u89E3\u51B3\u65B9\u6CD5\uFF1A",
    retry: "\u91CD\u8BD5",
    close: "\u5173\u95ED",
    // Error Suggestions
    suggestionCheckApiKey: "\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u68C0\u67E5API\u5BC6\u94A5",
    suggestionVerifyApiKey: "\u8BF7\u786E\u8BA4API\u5BC6\u94A5\u8F93\u5165\u6B63\u786E",
    suggestionActivateApiKey: "\u8BF7\u786E\u8BA4\u8BE5\u670D\u52A1\u7684API\u5BC6\u94A5\u5DF2\u6FC0\u6D3B",
    suggestionWaitAndRetry: "\u8BF7\u7A0D\u540E\u91CD\u8BD5",
    suggestionCheckQuota: "\u8BF7\u68C0\u67E5API\u4F7F\u7528\u914D\u989D",
    suggestionCheckInternet: "\u8BF7\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5",
    suggestionCheckVPN: "\u8BF7\u68C0\u67E5VPN\u6216\u4EE3\u7406\u8BBE\u7F6E",
    suggestionTryDifferentStyle: "\u8BF7\u5C1D\u8BD5\u5176\u4ED6\u98CE\u683C",
    suggestionModifyContent: "\u8BF7\u4FEE\u6539\u7B14\u8BB0\u5185\u5BB9\u540E\u91CD\u8BD5",
    suggestionContentMayBeSensitive: "\u5185\u5BB9\u53EF\u80FD\u5305\u542B\u654F\u611F\u4FE1\u606F",
    suggestionAddContent: "\u8BF7\u5728\u7B14\u8BB0\u4E2D\u6DFB\u52A0\u5185\u5BB9",
    // Preview Modal
    previewTitle: "\u{1F4DD} \u63D0\u793A\u8BCD\u9884\u89C8",
    previewPromptLabel: "\u751F\u6210\u7684\u63D0\u793A\u8BCD (\u53EF\u7F16\u8F91):",
    previewCharacters: "\u5B57\u7B26",
    previewTipsTitle: "\u{1F4A1} \u63D0\u793A:",
    previewTip1: "\u60A8\u53EF\u4EE5\u7F16\u8F91\u63D0\u793A\u8BCD\u4EE5\u8C03\u6574\u6240\u9700\u6837\u5F0F",
    previewTip2: "\u6DFB\u52A0\u5177\u4F53\u7684\u989C\u8272\u3001\u5E03\u5C40\u548C\u5143\u7D20\u5C06\u83B7\u5F97\u66F4\u597D\u7684\u6548\u679C",
    previewTip3: '\u4F7F\u7528"\u91CD\u65B0\u751F\u6210"\u6309\u94AE\u521B\u5EFA\u65B0\u7684\u63D0\u793A\u8BCD',
    previewGenerate: "\u{1F3A8} \u751F\u6210\u56FE\u7247",
    previewRegenerate: "\u{1F504} \u91CD\u65B0\u751F\u6210",
    previewPromptModel: "\u{1F916} \u63D0\u793A\u8BCD\u6A21\u578B",
    previewImageModel: "\u{1F5BC}\uFE0F \u56FE\u7247\u6A21\u578B",
    previewStyle: "\u{1F4CA} \u98CE\u683C"
  },
  es: {
    // Progress Modal
    progressTitle: "\u{1F3A8} Generando p\xF3ster de conocimiento...",
    estimatedTime: "\u23F1\uFE0F Tiempo estimado: aproximadamente 15-30 segundos",
    cancel: "Cancelar",
    // Progress Steps
    stepAnalyzing: "Analizando nota",
    stepGeneratingPrompt: "Generando prompt",
    stepGeneratingImage: "Generando imagen",
    stepSaving: "Guardando archivo",
    stepEmbedding: "Insertando en nota",
    // Success
    successTitle: "\u2705 \xA1P\xF3ster de conocimiento creado!",
    successSaved: "\u{1F4C1} Guardado en",
    confirm: "Aceptar",
    // Error
    errorTitle: "\u274C Generaci\xF3n fallida",
    errorSolutions: "\u{1F4A1} Soluciones:",
    retry: "Reintentar",
    close: "Cerrar",
    // Error Suggestions
    suggestionCheckApiKey: "Por favor, verifica tu clave API en la configuraci\xF3n",
    suggestionVerifyApiKey: "Por favor, verifica que tu clave API est\xE9 ingresada correctamente",
    suggestionActivateApiKey: "Por favor, aseg\xFArate de que la clave API est\xE9 activada para este servicio",
    suggestionWaitAndRetry: "Por favor, espera un momento e int\xE9ntalo de nuevo",
    suggestionCheckQuota: "Por favor, verifica tu cuota de uso de API",
    suggestionCheckInternet: "Por favor, verifica tu conexi\xF3n a internet",
    suggestionCheckVPN: "Por favor, verifica tu configuraci\xF3n de VPN o proxy",
    suggestionTryDifferentStyle: "Por favor, intenta con un estilo diferente",
    suggestionModifyContent: "Por favor, modifica el contenido de la nota e int\xE9ntalo de nuevo",
    suggestionContentMayBeSensitive: "El contenido puede contener material sensible",
    suggestionAddContent: "Por favor, agrega contenido a tu nota",
    // Preview Modal
    previewTitle: "\u{1F4DD} Vista previa del prompt",
    previewPromptLabel: "Prompt generado (editable):",
    previewCharacters: "caracteres",
    previewTipsTitle: "\u{1F4A1} Consejos:",
    previewTip1: "Puedes editar el prompt para ajustar el estilo deseado",
    previewTip2: "Agregar colores, dise\xF1os y elementos espec\xEDficos dar\xE1 mejores resultados",
    previewTip3: 'Usa el bot\xF3n "Regenerar" para crear un nuevo prompt',
    previewGenerate: "\u{1F3A8} Generar imagen",
    previewRegenerate: "\u{1F504} Regenerar",
    previewPromptModel: "\u{1F916} Modelo de prompt",
    previewImageModel: "\u{1F5BC}\uFE0F Modelo de imagen",
    previewStyle: "\u{1F4CA} Estilo"
  },
  fr: {
    // Progress Modal
    progressTitle: "\u{1F3A8} G\xE9n\xE9ration de l'affiche de connaissances...",
    estimatedTime: "\u23F1\uFE0F Temps estim\xE9 : environ 15-30 secondes",
    cancel: "Annuler",
    // Progress Steps
    stepAnalyzing: "Analyse de la note",
    stepGeneratingPrompt: "G\xE9n\xE9ration du prompt",
    stepGeneratingImage: "G\xE9n\xE9ration de l'image",
    stepSaving: "Enregistrement du fichier",
    stepEmbedding: "Insertion dans la note",
    // Success
    successTitle: "\u2705 Affiche de connaissances cr\xE9\xE9e !",
    successSaved: "\u{1F4C1} Enregistr\xE9 dans",
    confirm: "OK",
    // Error
    errorTitle: "\u274C \xC9chec de la g\xE9n\xE9ration",
    errorSolutions: "\u{1F4A1} Solutions :",
    retry: "R\xE9essayer",
    close: "Fermer",
    // Error Suggestions
    suggestionCheckApiKey: "Veuillez v\xE9rifier votre cl\xE9 API dans les param\xE8tres",
    suggestionVerifyApiKey: "Veuillez v\xE9rifier que votre cl\xE9 API est correctement saisie",
    suggestionActivateApiKey: "Veuillez vous assurer que la cl\xE9 API est activ\xE9e pour ce service",
    suggestionWaitAndRetry: "Veuillez attendre un moment et r\xE9essayer",
    suggestionCheckQuota: "Veuillez v\xE9rifier votre quota d'utilisation de l'API",
    suggestionCheckInternet: "Veuillez v\xE9rifier votre connexion Internet",
    suggestionCheckVPN: "Veuillez v\xE9rifier vos param\xE8tres VPN ou proxy",
    suggestionTryDifferentStyle: "Veuillez essayer un style diff\xE9rent",
    suggestionModifyContent: "Veuillez modifier le contenu de la note et r\xE9essayer",
    suggestionContentMayBeSensitive: "Le contenu peut contenir du mat\xE9riel sensible",
    suggestionAddContent: "Veuillez ajouter du contenu \xE0 votre note",
    // Preview Modal
    previewTitle: "\u{1F4DD} Aper\xE7u du prompt",
    previewPromptLabel: "Prompt g\xE9n\xE9r\xE9 (modifiable):",
    previewCharacters: "caract\xE8res",
    previewTipsTitle: "\u{1F4A1} Conseils:",
    previewTip1: "Vous pouvez modifier le prompt pour ajuster le style souhait\xE9",
    previewTip2: "Ajouter des couleurs, des mises en page et des \xE9l\xE9ments sp\xE9cifiques donnera de meilleurs r\xE9sultats",
    previewTip3: 'Utilisez le bouton "R\xE9g\xE9n\xE9rer" pour cr\xE9er un nouveau prompt',
    previewGenerate: "\u{1F3A8} G\xE9n\xE9rer l'image",
    previewRegenerate: "\u{1F504} R\xE9g\xE9n\xE9rer",
    previewPromptModel: "\u{1F916} Mod\xE8le de prompt",
    previewImageModel: "\u{1F5BC}\uFE0F Mod\xE8le d'image",
    previewStyle: "\u{1F4CA} Style"
  },
  de: {
    // Progress Modal
    progressTitle: "\u{1F3A8} Wissensposter wird erstellt...",
    estimatedTime: "\u23F1\uFE0F Gesch\xE4tzte Zeit: etwa 15-30 Sekunden",
    cancel: "Abbrechen",
    // Progress Steps
    stepAnalyzing: "Notiz analysieren",
    stepGeneratingPrompt: "Prompt generieren",
    stepGeneratingImage: "Bild generieren",
    stepSaving: "Datei speichern",
    stepEmbedding: "In Notiz einf\xFCgen",
    // Success
    successTitle: "\u2705 Wissensposter erstellt!",
    successSaved: "\u{1F4C1} Gespeichert in",
    confirm: "OK",
    // Error
    errorTitle: "\u274C Generierung fehlgeschlagen",
    errorSolutions: "\u{1F4A1} L\xF6sungen:",
    retry: "Wiederholen",
    close: "Schlie\xDFen",
    // Error Suggestions
    suggestionCheckApiKey: "Bitte \xFCberpr\xFCfen Sie Ihren API-Schl\xFCssel in den Einstellungen",
    suggestionVerifyApiKey: "Bitte \xFCberpr\xFCfen Sie, ob Ihr API-Schl\xFCssel korrekt eingegeben wurde",
    suggestionActivateApiKey: "Bitte stellen Sie sicher, dass der API-Schl\xFCssel f\xFCr diesen Dienst aktiviert ist",
    suggestionWaitAndRetry: "Bitte warten Sie einen Moment und versuchen Sie es erneut",
    suggestionCheckQuota: "Bitte \xFCberpr\xFCfen Sie Ihr API-Nutzungskontingent",
    suggestionCheckInternet: "Bitte \xFCberpr\xFCfen Sie Ihre Internetverbindung",
    suggestionCheckVPN: "Bitte \xFCberpr\xFCfen Sie Ihre VPN- oder Proxy-Einstellungen",
    suggestionTryDifferentStyle: "Bitte versuchen Sie einen anderen Stil",
    suggestionModifyContent: "Bitte \xE4ndern Sie den Notizinhalt und versuchen Sie es erneut",
    suggestionContentMayBeSensitive: "Der Inhalt kann sensibles Material enthalten",
    suggestionAddContent: "Bitte f\xFCgen Sie Inhalt zu Ihrer Notiz hinzu",
    // Preview Modal
    previewTitle: "\u{1F4DD} Prompt-Vorschau",
    previewPromptLabel: "Generierter Prompt (bearbeitbar):",
    previewCharacters: "Zeichen",
    previewTipsTitle: "\u{1F4A1} Tipps:",
    previewTip1: "Sie k\xF6nnen den Prompt bearbeiten, um den gew\xFCnschten Stil anzupassen",
    previewTip2: "Das Hinzuf\xFCgen spezifischer Farben, Layouts und Elemente f\xFChrt zu besseren Ergebnissen",
    previewTip3: 'Verwenden Sie die Schaltfl\xE4che "Regenerieren", um einen neuen Prompt zu erstellen',
    previewGenerate: "\u{1F3A8} Bild generieren",
    previewRegenerate: "\u{1F504} Regenerieren",
    previewPromptModel: "\u{1F916} Prompt-Modell",
    previewImageModel: "\u{1F5BC}\uFE0F Bildmodell",
    previewStyle: "\u{1F4CA} Stil"
  }
};
function getMessages(language) {
  return MESSAGES[language] || MESSAGES.en;
}

// src/progressModal.ts
var ProgressModal = class extends import_obsidian5.Modal {
  constructor(app, language = "en") {
    super(app);
    this.onCancel = null;
    this.isCancelled = false;
    this.steps = [];
    this.messages = getMessages(language);
    this.steps = [
      { key: "analyzing", label: this.messages.stepAnalyzing, icon: "\u{1F4C4}" },
      { key: "generating-prompt", label: this.messages.stepGeneratingPrompt, icon: "\u{1F916}" },
      { key: "generating-image", label: this.messages.stepGeneratingImage, icon: "\u{1F3A8}" },
      { key: "saving", label: this.messages.stepSaving, icon: "\u{1F4BE}" },
      { key: "embedding", label: this.messages.stepEmbedding, icon: "\u{1F4CE}" }
    ];
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("nanobanana-progress-modal");
    contentEl.createEl("h2", {
      text: this.messages.progressTitle,
      cls: "nanobanana-progress-title"
    });
    this.progressContainer = contentEl.createDiv({ cls: "nanobanana-progress-container" });
    this.progressBar = this.progressContainer.createDiv({ cls: "nanobanana-progress-bar" });
    this.progressText = this.progressContainer.createDiv({
      cls: "nanobanana-progress-text",
      text: "0%"
    });
    this.stepsContainer = contentEl.createDiv({ cls: "nanobanana-steps-container" });
    this.renderSteps();
    contentEl.createDiv({
      cls: "nanobanana-estimated-time",
      text: this.messages.estimatedTime
    });
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    this.cancelButton = buttonContainer.createEl("button", {
      text: this.messages.cancel,
      cls: "nanobanana-cancel-button"
    });
    this.cancelButton.addEventListener("click", () => {
      this.isCancelled = true;
      if (this.onCancel) {
        this.onCancel();
      }
      this.close();
    });
  }
  renderSteps() {
    this.stepsContainer.empty();
    for (const step of this.steps) {
      const stepEl = this.stepsContainer.createDiv({ cls: "nanobanana-step" });
      stepEl.createSpan({ cls: "nanobanana-step-icon", text: "\u23F3" });
      stepEl.createSpan({ cls: "nanobanana-step-label", text: `${step.icon} ${step.label}` });
      stepEl.dataset.step = step.key;
    }
  }
  updateProgress(state) {
    if (this.isCancelled)
      return;
    this.progressBar.style.width = `${state.progress}%`;
    this.progressText.setText(`${Math.round(state.progress)}%`);
    const stepIndex = this.steps.findIndex((s) => s.key === state.step);
    const stepElements = this.stepsContainer.querySelectorAll(".nanobanana-step");
    stepElements.forEach((el, index) => {
      const iconEl = el.querySelector(".nanobanana-step-icon");
      if (!iconEl)
        return;
      if (index < stepIndex) {
        el.addClass("completed");
        el.removeClass("active");
        iconEl.setText("\u2705");
      } else if (index === stepIndex) {
        el.addClass("active");
        el.removeClass("completed");
        iconEl.setText("\u{1F504}");
      } else {
        el.removeClass("active", "completed");
        iconEl.setText("\u23F3");
      }
    });
  }
  showError(error) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("nanobanana-error-state");
    contentEl.createEl("h2", {
      text: this.messages.errorTitle,
      cls: "nanobanana-error-title"
    });
    const errorBox = contentEl.createDiv({ cls: "nanobanana-error-box" });
    errorBox.createEl("p", { text: error.message });
    if (error.details) {
      errorBox.createEl("p", {
        text: error.details,
        cls: "nanobanana-error-details"
      });
    }
    const suggestions = this.getErrorSuggestions(error);
    if (suggestions.length > 0) {
      const suggestionBox = contentEl.createDiv({ cls: "nanobanana-suggestions" });
      suggestionBox.createEl("p", { text: this.messages.errorSolutions });
      const list = suggestionBox.createEl("ul");
      for (const suggestion of suggestions) {
        list.createEl("li", { text: suggestion });
      }
    }
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    if (error.retryable) {
      const retryButton = buttonContainer.createEl("button", {
        text: this.messages.retry,
        cls: "nanobanana-retry-button mod-cta"
      });
      retryButton.addEventListener("click", () => {
        if (this.onCancel) {
          this.close();
        }
      });
    }
    const closeButton = buttonContainer.createEl("button", {
      text: this.messages.close,
      cls: "nanobanana-close-button"
    });
    closeButton.addEventListener("click", () => this.close());
  }
  showSuccess(imagePath) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("nanobanana-success-state");
    contentEl.createEl("h2", {
      text: this.messages.successTitle,
      cls: "nanobanana-success-title"
    });
    const infoBox = contentEl.createDiv({ cls: "nanobanana-success-box" });
    infoBox.createEl("p", { text: `${this.messages.successSaved}: ${imagePath}` });
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    const closeButton = buttonContainer.createEl("button", {
      text: this.messages.confirm,
      cls: "nanobanana-close-button mod-cta"
    });
    closeButton.addEventListener("click", () => this.close());
    setTimeout(() => {
      if (!this.isCancelled) {
        this.close();
      }
    }, 3e3);
  }
  getErrorSuggestions(error) {
    switch (error.type) {
      case "INVALID_API_KEY":
        return [
          this.messages.suggestionCheckApiKey,
          this.messages.suggestionVerifyApiKey,
          this.messages.suggestionActivateApiKey
        ];
      case "RATE_LIMIT":
        return [
          this.messages.suggestionWaitAndRetry,
          this.messages.suggestionCheckQuota
        ];
      case "NETWORK_ERROR":
        return [
          this.messages.suggestionCheckInternet,
          this.messages.suggestionCheckVPN
        ];
      case "GENERATION_FAILED":
        return [
          this.messages.suggestionTryDifferentStyle,
          this.messages.suggestionModifyContent
        ];
      case "CONTENT_FILTERED":
        return [
          this.messages.suggestionModifyContent,
          this.messages.suggestionContentMayBeSensitive
        ];
      case "NO_CONTENT":
        return [
          this.messages.suggestionAddContent
        ];
      default:
        return [];
    }
  }
  setOnCancel(callback) {
    this.onCancel = callback;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/previewModal.ts
var import_obsidian6 = require("obsidian");
var PreviewModal = class extends import_obsidian6.Modal {
  constructor(app, prompt, settings, onConfirm, language = "en") {
    super(app);
    this.prompt = prompt;
    this.settings = settings;
    this.onConfirm = onConfirm;
    this.messages = getMessages(language);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("nanobanana-preview-modal");
    contentEl.createEl("h2", {
      text: this.messages.previewTitle,
      cls: "nanobanana-preview-title"
    });
    const infoSection = contentEl.createDiv({ cls: "nanobanana-preview-info" });
    infoSection.createDiv({
      cls: "nanobanana-preview-info-item",
      text: `${this.messages.previewPromptModel}: ${PROVIDER_CONFIGS[this.settings.selectedProvider].name} - ${this.settings.promptModel}`
    });
    infoSection.createDiv({
      cls: "nanobanana-preview-info-item",
      text: `${this.messages.previewImageModel}: ${this.settings.imageModel}`
    });
    infoSection.createDiv({
      cls: "nanobanana-preview-info-item",
      text: `${this.messages.previewStyle}: ${IMAGE_STYLES[this.settings.imageStyle]}`
    });
    const textareaContainer = contentEl.createDiv({ cls: "nanobanana-textarea-container" });
    textareaContainer.createEl("label", {
      text: this.messages.previewPromptLabel,
      cls: "nanobanana-textarea-label"
    });
    this.promptTextarea = textareaContainer.createEl("textarea", {
      cls: "nanobanana-prompt-textarea"
    });
    this.promptTextarea.value = this.prompt;
    this.promptTextarea.rows = 10;
    const charCount = textareaContainer.createDiv({ cls: "nanobanana-char-count" });
    charCount.setText(`${this.prompt.length} ${this.messages.previewCharacters}`);
    this.promptTextarea.addEventListener("input", () => {
      charCount.setText(`${this.promptTextarea.value.length} ${this.messages.previewCharacters}`);
    });
    const tipsSection = contentEl.createDiv({ cls: "nanobanana-tips" });
    tipsSection.createEl("p", { text: this.messages.previewTipsTitle });
    const tipsList = tipsSection.createEl("ul");
    tipsList.createEl("li", { text: this.messages.previewTip1 });
    tipsList.createEl("li", { text: this.messages.previewTip2 });
    tipsList.createEl("li", { text: this.messages.previewTip3 });
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    const generateButton = buttonContainer.createEl("button", {
      text: this.messages.previewGenerate,
      cls: "mod-cta"
    });
    generateButton.addEventListener("click", () => {
      this.onConfirm({
        confirmed: true,
        prompt: this.promptTextarea.value,
        regenerate: false
      });
      this.close();
    });
    const regenerateButton = buttonContainer.createEl("button", {
      text: this.messages.previewRegenerate
    });
    regenerateButton.addEventListener("click", () => {
      this.onConfirm({
        confirmed: true,
        prompt: "",
        regenerate: true
      });
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: this.messages.cancel
    });
    cancelButton.addEventListener("click", () => {
      this.onConfirm({
        confirmed: false,
        prompt: "",
        regenerate: false
      });
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/quickOptionsModal.ts
var import_obsidian7 = require("obsidian");
var QuickOptionsModal = class extends import_obsidian7.Modal {
  constructor(app, currentStyle, currentSize, currentCartoonCuts, currentCustomCuts, onSubmit) {
    super(app);
    this.cartoonSettingsContainer = null;
    this.selectedStyle = currentStyle;
    this.selectedSize = currentSize;
    this.selectedCartoonCuts = currentCartoonCuts;
    this.selectedCustomCuts = currentCustomCuts;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("nanobanana-quick-options");
    contentEl.createEl("h2", {
      text: "\u{1F3A8} quick options",
      cls: "nanobanana-modal-title"
    });
    contentEl.createEl("p", {
      text: "Choose image style and resolution for this generation.",
      cls: "nanobanana-modal-desc"
    });
    new import_obsidian7.Setting(contentEl).setName("Image style").setDesc("Select the visual style for your knowledge poster").addDropdown(
      (dropdown) => dropdown.addOptions({
        "infographic": "\u{1F4CA} infographic - charts & visual hierarchy",
        "poster": "\u{1F3A8} poster - bold typography & imagery",
        "diagram": "\u{1F4D0} diagram - technical connections",
        "mindmap": "\u{1F9E0} mind map - central concept & branches",
        "timeline": "\u{1F4C5} timeline - progression & milestones",
        "cartoon": "\u{1F3AC} cartoon - comic strip panels"
      }).setValue(this.selectedStyle).onChange((value) => {
        this.selectedStyle = value;
        this.updateCartoonSettings();
      })
    );
    this.cartoonSettingsContainer = contentEl.createDiv({ cls: "nanobanana-cartoon-settings" });
    this.updateCartoonSettings();
    new import_obsidian7.Setting(contentEl).setName("Image resolution").setDesc("Higher resolution = better quality (4K recommended for Korean text)").addDropdown(
      (dropdown) => dropdown.addOptions({
        "1K": "1K - standard quality",
        "2K": "2K - high quality",
        "4K": "4K - ultra HD quality \u2B50"
      }).setValue(this.selectedSize).onChange((value) => {
        this.selectedSize = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "nanobanana-btn nanobanana-btn-cancel"
    });
    cancelBtn.onclick = () => {
      this.onSubmit({
        confirmed: false,
        imageStyle: this.selectedStyle,
        imageSize: this.selectedSize,
        cartoonCuts: this.selectedCartoonCuts,
        customCartoonCuts: this.selectedCustomCuts
      });
      this.close();
    };
    const generateBtn = buttonContainer.createEl("button", {
      text: "\u{1F680} Generate poster",
      cls: "nanobanana-btn nanobanana-btn-primary"
    });
    generateBtn.onclick = () => {
      this.onSubmit({
        confirmed: true,
        imageStyle: this.selectedStyle,
        imageSize: this.selectedSize,
        cartoonCuts: this.selectedCartoonCuts,
        customCartoonCuts: this.selectedCustomCuts
      });
      this.close();
    };
  }
  updateCartoonSettings() {
    if (!this.cartoonSettingsContainer)
      return;
    this.cartoonSettingsContainer.empty();
    if (this.selectedStyle !== "cartoon") {
      this.cartoonSettingsContainer.addClass("nanobanana-hidden");
      return;
    }
    this.cartoonSettingsContainer.removeClass("nanobanana-hidden");
    new import_obsidian7.Setting(this.cartoonSettingsContainer).setName("Panel cuts").setDesc("Number of panels in the comic strip").addDropdown(
      (dropdown) => dropdown.addOptions({
        "4": "4 cuts (2\xD72 grid)",
        "6": "6 cuts (2\xD73 grid)",
        "8": "8 cuts (2\xD74 grid)",
        "custom": "custom number"
      }).setValue(this.selectedCartoonCuts).onChange((value) => {
        this.selectedCartoonCuts = value;
        this.updateCartoonSettings();
      })
    );
    if (this.selectedCartoonCuts === "custom") {
      new import_obsidian7.Setting(this.cartoonSettingsContainer).setName("Custom panel count").setDesc("Enter number of panels (2-12 recommended)").addText(
        (text) => text.setPlaceholder("4").setValue(String(this.selectedCustomCuts)).onChange((value) => {
          const numValue = parseInt(value) || 4;
          this.selectedCustomCuts = Math.max(2, Math.min(12, numValue));
        })
      );
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var NanoBananaPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.lastPrompt = "";
    this.lastNoteFile = null;
    this.isGenerating = false;
  }
  async onload() {
    await this.loadSettings();
    this.promptService = new PromptService();
    this.imageService = new ImageService();
    this.fileService = new FileService(this.app);
    this.addCommand({
      id: "generate-knowledge-poster",
      name: "Generate knowledge poster",
      callback: () => this.generatePoster()
    });
    this.addCommand({
      id: "generate-prompt-only",
      name: "Generate prompt only (copy to clipboard)",
      callback: () => this.generatePromptOnly()
    });
    this.addCommand({
      id: "regenerate-last-poster",
      name: "Regenerate last poster",
      callback: () => this.regenerateLastPoster()
    });
    this.addSettingTab(new NanoBananaSettingTab(this.app, this));
    console.debug("NanoBanana PRO loaded");
  }
  onunload() {
    console.debug("NanoBanana PRO unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Main generation flow
   */
  async generatePoster() {
    if (this.isGenerating) {
      new import_obsidian8.Notice("Generation already in progress");
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
    if (!activeView || !activeView.file) {
      new import_obsidian8.Notice("Please open a note first");
      return;
    }
    const noteFile = activeView.file;
    const noteContent = await this.app.vault.read(noteFile);
    if (!noteContent.trim()) {
      new import_obsidian8.Notice("Note is empty. Please add some content first.");
      return;
    }
    if (!this.settings.googleApiKey) {
      new import_obsidian8.Notice("Google API key is required for image generation. Please configure it in settings.");
      return;
    }
    const providerKey = this.getProviderApiKey();
    if (!providerKey) {
      new import_obsidian8.Notice(`${this.settings.selectedProvider} API key is not configured. Please check settings.`);
      return;
    }
    const quickOptions = await this.showQuickOptionsModal();
    if (!quickOptions.confirmed) {
      return;
    }
    const selectedStyle = quickOptions.imageStyle;
    const selectedSize = quickOptions.imageSize;
    const selectedCartoonCuts = this.getCartoonCutsNumber(quickOptions.cartoonCuts, quickOptions.customCartoonCuts);
    this.isGenerating = true;
    this.lastNoteFile = noteFile;
    let progressModal = null;
    try {
      if (this.settings.showProgressModal) {
        progressModal = new ProgressModal(this.app, this.settings.preferredLanguage);
        progressModal.open();
      }
      this.updateProgress(progressModal, {
        step: "generating-prompt",
        progress: 20,
        message: "\uD504\uB86C\uD504\uD2B8 \uC0DD\uC131 \uC911..."
      });
      const promptResult = await this.executeWithRetry(async () => {
        return await this.promptService.generatePrompt(
          noteContent,
          this.settings.selectedProvider,
          this.settings.promptModel,
          providerKey
        );
      });
      let finalPrompt = promptResult.prompt;
      this.lastPrompt = finalPrompt;
      if (this.settings.customPromptPrefix) {
        finalPrompt = `${this.settings.customPromptPrefix}

${finalPrompt}`;
      }
      if (this.settings.showPreviewBeforeGeneration) {
        if (progressModal) {
          progressModal.close();
          progressModal = null;
        }
        const previewResult = await this.showPreviewModal(finalPrompt);
        if (!previewResult.confirmed) {
          this.isGenerating = false;
          return;
        }
        if (previewResult.regenerate) {
          this.isGenerating = false;
          return this.generatePoster();
        }
        finalPrompt = previewResult.prompt;
        if (this.settings.showProgressModal) {
          progressModal = new ProgressModal(this.app, this.settings.preferredLanguage);
          progressModal.open();
        }
      }
      this.updateProgress(progressModal, {
        step: "generating-image",
        progress: 50,
        message: "\uC774\uBBF8\uC9C0 \uC0DD\uC131 \uC911..."
      });
      const imageResult = await this.executeWithRetry(async () => {
        return await this.imageService.generateImage(
          finalPrompt,
          this.settings.googleApiKey,
          this.settings.imageModel,
          selectedStyle,
          this.settings.preferredLanguage,
          selectedSize,
          selectedCartoonCuts
        );
      });
      this.updateProgress(progressModal, {
        step: "saving",
        progress: 80,
        message: "\uD30C\uC77C \uC800\uC7A5 \uC911..."
      });
      const imagePath = await this.fileService.saveImage(
        imageResult.imageData,
        imageResult.mimeType,
        noteFile,
        this.settings.attachmentFolder
      );
      this.updateProgress(progressModal, {
        step: "embedding",
        progress: 95,
        message: "\uB178\uD2B8\uC5D0 \uC0BD\uC785 \uC911..."
      });
      await this.fileService.embedImageInNote(noteFile, imagePath);
      this.updateProgress(progressModal, {
        step: "complete",
        progress: 100,
        message: "\uC644\uB8CC!"
      });
      if (progressModal) {
        progressModal.showSuccess(imagePath);
      } else {
        new import_obsidian8.Notice("\u2705 Knowledge poster generated successfully!");
      }
    } catch (error) {
      const genError = error;
      if (progressModal) {
        progressModal.showError(genError);
      } else {
        new import_obsidian8.Notice(`\u274C Generation failed: ${genError.message}`);
      }
      console.error("NanoBanana PRO error:", error);
      if (error instanceof Error) {
        console.error("Error message:", error.message);
        console.error("Error stack:", error.stack);
      } else if (typeof error === "object" && error !== null) {
        console.error("Error details:", JSON.stringify(error, null, 2));
      }
    } finally {
      this.isGenerating = false;
    }
  }
  /**
   * Generate prompt only and copy to clipboard
   */
  async generatePromptOnly() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
    if (!activeView || !activeView.file) {
      new import_obsidian8.Notice("Please open a note first");
      return;
    }
    const noteContent = await this.app.vault.read(activeView.file);
    if (!noteContent.trim()) {
      new import_obsidian8.Notice("Note is empty");
      return;
    }
    const providerKey = this.getProviderApiKey();
    if (!providerKey) {
      new import_obsidian8.Notice(`${this.settings.selectedProvider} API key is not configured`);
      return;
    }
    try {
      new import_obsidian8.Notice("Generating prompt...");
      const result = await this.promptService.generatePrompt(
        noteContent,
        this.settings.selectedProvider,
        this.settings.promptModel,
        providerKey
      );
      await navigator.clipboard.writeText(result.prompt);
      this.lastPrompt = result.prompt;
      new import_obsidian8.Notice("\u2705 Prompt copied to clipboard!");
    } catch (error) {
      const genError = error;
      new import_obsidian8.Notice(`\u274C Failed: ${genError.message}`);
    }
  }
  /**
   * Regenerate using the last prompt
   */
  async regenerateLastPoster() {
    if (!this.lastPrompt) {
      new import_obsidian8.Notice("No previous generation found. Please generate a poster first.");
      return;
    }
    if (!this.lastNoteFile) {
      new import_obsidian8.Notice("Original note not found. Please generate a new poster.");
      return;
    }
    const file = this.app.vault.getAbstractFileByPath(this.lastNoteFile.path);
    if (!file || !(file instanceof import_obsidian8.TFile)) {
      new import_obsidian8.Notice("Original note was moved or deleted");
      return;
    }
    if (this.isGenerating) {
      new import_obsidian8.Notice("Generation already in progress");
      return;
    }
    this.isGenerating = true;
    let progressModal = null;
    try {
      if (this.settings.showProgressModal) {
        progressModal = new ProgressModal(this.app, this.settings.preferredLanguage);
        progressModal.open();
      }
      this.updateProgress(progressModal, {
        step: "generating-image",
        progress: 40,
        message: "\uC774\uBBF8\uC9C0 \uC0DD\uC131 \uC911..."
      });
      const imageResult = await this.executeWithRetry(async () => {
        return await this.imageService.generateImage(
          this.lastPrompt,
          this.settings.googleApiKey,
          this.settings.imageModel,
          this.settings.imageStyle,
          this.settings.preferredLanguage,
          this.settings.imageSize,
          this.getCartoonCutsNumber(this.settings.cartoonCuts, this.settings.customCartoonCuts)
        );
      });
      this.updateProgress(progressModal, {
        step: "saving",
        progress: 80,
        message: "\uD30C\uC77C \uC800\uC7A5 \uC911..."
      });
      const imagePath = await this.fileService.saveImage(
        imageResult.imageData,
        imageResult.mimeType,
        this.lastNoteFile,
        this.settings.attachmentFolder
      );
      this.updateProgress(progressModal, {
        step: "embedding",
        progress: 95,
        message: "\uB178\uD2B8\uC5D0 \uC0BD\uC785 \uC911..."
      });
      await this.fileService.embedImageInNote(this.lastNoteFile, imagePath);
      if (progressModal) {
        progressModal.showSuccess(imagePath);
      } else {
        new import_obsidian8.Notice("\u2705 Poster regenerated successfully!");
      }
    } catch (error) {
      const genError = error;
      if (progressModal) {
        progressModal.showError(genError);
      } else {
        new import_obsidian8.Notice(`\u274C Regeneration failed: ${genError.message}`);
      }
    } finally {
      this.isGenerating = false;
    }
  }
  /**
   * Show preview modal and wait for user decision
   */
  showPreviewModal(prompt) {
    return new Promise((resolve) => {
      const modal = new PreviewModal(
        this.app,
        prompt,
        this.settings,
        (result) => resolve(result),
        this.settings.preferredLanguage
      );
      modal.open();
    });
  }
  /**
   * Show quick options modal for style and resolution selection
   */
  showQuickOptionsModal() {
    return new Promise((resolve) => {
      const modal = new QuickOptionsModal(
        this.app,
        this.settings.imageStyle,
        this.settings.imageSize,
        this.settings.cartoonCuts,
        this.settings.customCartoonCuts,
        (result) => resolve(result)
      );
      modal.open();
    });
  }
  /**
   * Calculate actual number of cartoon cuts
   */
  getCartoonCutsNumber(cartoonCuts, customCuts) {
    if (cartoonCuts === "custom") {
      return customCuts;
    }
    return parseInt(cartoonCuts);
  }
  /**
   * Execute operation with auto-retry
   */
  async executeWithRetry(operation) {
    let lastError = null;
    for (let attempt = 0; attempt <= this.settings.autoRetryCount; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (!lastError.retryable || attempt === this.settings.autoRetryCount) {
          throw lastError instanceof Error ? lastError : new Error((lastError == null ? void 0 : lastError.message) || "Unknown error");
        }
        const delay = Math.pow(2, attempt) * 1e3;
        await this.sleep(delay);
      }
    }
    throw lastError instanceof Error ? lastError : new Error("Operation failed with no error details");
  }
  /**
   * Update progress modal
   */
  updateProgress(modal, state) {
    if (modal) {
      modal.updateProgress(state);
    }
  }
  /**
   * Get API key for the selected provider
   */
  getProviderApiKey() {
    switch (this.settings.selectedProvider) {
      case "openai":
        return this.settings.openaiApiKey;
      case "google":
        return this.settings.googleApiKey;
      case "anthropic":
        return this.settings.anthropicApiKey;
      case "xai":
        return this.settings.xaiApiKey;
      default:
        return "";
    }
  }
  /**
   * Sleep utility
   */
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
};
