/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NanoBananaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/settingsData.ts
var DEFAULT_SETTINGS = {
  // API Keys
  googleApiKey: "",
  openaiApiKey: "",
  anthropicApiKey: "",
  xaiApiKey: "",
  // Prompt Generation
  selectedProvider: "google",
  promptModel: "gemini-2.5-flash",
  // Image Generation
  imageModel: "gemini-3-pro-image-preview",
  imageStyle: "infographic",
  preferredLanguage: "ko",
  // UX Settings
  showPreviewBeforeGeneration: true,
  attachmentFolder: "999-Attachments",
  autoRetryCount: 2,
  showProgressModal: true,
  // Advanced
  customPromptPrefix: ""
};
var SYSTEM_PROMPT = `You are an expert visual designer and infographic creator. Your task is to analyze the given content and generate a detailed prompt for creating a visually stunning knowledge poster/infographic.

The prompt you generate will be used by an AI image generation model. Be specific about:
1. Visual layout and composition
2. Color scheme and style
3. Typography hierarchy
4. Icons and visual elements
5. Data visualization if applicable
6. Overall mood and aesthetic

Generate ONLY the image prompt, no explanations or additional text.

Important guidelines:
- The poster should be educational and informative
- Use modern, clean design principles
- Include visual representations of key concepts
- Make it visually engaging and easy to understand
- The text in the image should be minimal but impactful
- Focus on visual storytelling

Output format: A single, detailed image generation prompt.`;
var IMAGE_GENERATION_PROMPT_TEMPLATE = `Create a stunning, professional knowledge poster/infographic with the following specifications:

STYLE: {style}

CONTENT TO VISUALIZE:
{prompt}

Design requirements:
- Modern, clean aesthetic with professional typography
- Clear visual hierarchy with main title, subtopics, and details
- Use icons and visual metaphors to represent concepts
- Include subtle decorative elements that enhance readability
- Color palette should be harmonious and professional
- Layout should guide the eye through the information
- Text should be minimal but impactful
- Include visual representations of data/concepts where applicable
- Make it suitable for educational/professional use
- Ensure high contrast for readability`;

// src/settings.ts
var import_obsidian = require("obsidian");

// src/types.ts
var PROVIDER_CONFIGS = {
  openai: {
    name: "OpenAI",
    endpoint: "https://api.openai.com/v1/chat/completions",
    defaultModel: "gpt-4o",
    models: ["gpt-4o", "gpt-4o-mini", "gpt-4-turbo", "gpt-3.5-turbo"]
  },
  google: {
    name: "Google Gemini",
    endpoint: "https://generativelanguage.googleapis.com/v1beta/models",
    defaultModel: "gemini-2.5-flash",
    models: ["gemini-2.5-flash", "gemini-2.0-flash-exp", "gemini-1.5-pro", "gemini-1.5-flash"]
  },
  anthropic: {
    name: "Anthropic",
    endpoint: "https://api.anthropic.com/v1/messages",
    defaultModel: "claude-sonnet-4-20250514",
    models: ["claude-sonnet-4-20250514", "claude-3-5-sonnet-20241022", "claude-3-haiku-20240307"]
  },
  xai: {
    name: "xAI",
    endpoint: "https://api.x.ai/v1/chat/completions",
    defaultModel: "grok-4-1-fast",
    models: ["grok-4-1-fast", "grok-beta", "grok-2"]
  }
};
var IMAGE_STYLES = {
  infographic: "Modern infographic with icons, charts, and visual hierarchy",
  poster: "Bold poster design with strong typography and imagery",
  diagram: "Technical diagram with clear connections and labels",
  mindmap: "Mind map style with central concept and branches",
  timeline: "Timeline format showing progression and milestones"
};

// src/settings.ts
var NanoBananaSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "\u{1F34C} NanoBanana PRO Settings" });
    containerEl.createEl("h2", { text: "\u{1F511} API Keys" });
    new import_obsidian.Setting(containerEl).setName("Google API Key").setDesc("Required for image generation. Get your key from Google AI Studio.").addText(
      (text) => text.setPlaceholder("Enter your Google API key").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
        this.plugin.settings.googleApiKey = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("external-link").setTooltip("Get API Key").onClick(() => {
        window.open("https://aistudio.google.com/apikey");
      })
    );
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Optional. Used for prompt generation if OpenAI is selected.").addText(
      (text) => text.setPlaceholder("Enter your OpenAI API key").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("external-link").setTooltip("Get API Key").onClick(() => {
        window.open("https://platform.openai.com/api-keys");
      })
    );
    new import_obsidian.Setting(containerEl).setName("Anthropic API Key").setDesc("Optional. Used for prompt generation if Anthropic is selected.").addText(
      (text) => text.setPlaceholder("Enter your Anthropic API key").setValue(this.plugin.settings.anthropicApiKey).onChange(async (value) => {
        this.plugin.settings.anthropicApiKey = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("external-link").setTooltip("Get API Key").onClick(() => {
        window.open("https://console.anthropic.com/settings/keys");
      })
    );
    new import_obsidian.Setting(containerEl).setName("xAI API Key").setDesc("Optional. Used for prompt generation if xAI is selected.").addText(
      (text) => text.setPlaceholder("Enter your xAI API key").setValue(this.plugin.settings.xaiApiKey).onChange(async (value) => {
        this.plugin.settings.xaiApiKey = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("external-link").setTooltip("Get API Key").onClick(() => {
        window.open("https://console.x.ai/");
      })
    );
    containerEl.createEl("h2", { text: "\u{1F916} Prompt Generation" });
    new import_obsidian.Setting(containerEl).setName("AI Provider").setDesc("Select which AI provider to use for generating image prompts.").addDropdown(
      (dropdown) => dropdown.addOptions({
        "google": "Google Gemini",
        "openai": "OpenAI",
        "anthropic": "Anthropic",
        "xai": "xAI (Grok)"
      }).setValue(this.plugin.settings.selectedProvider).onChange(async (value) => {
        this.plugin.settings.selectedProvider = value;
        this.plugin.settings.promptModel = PROVIDER_CONFIGS[value].defaultModel;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    const providerConfig = PROVIDER_CONFIGS[this.plugin.settings.selectedProvider];
    new import_obsidian.Setting(containerEl).setName("Prompt Model").setDesc(`Model to use for prompt generation. Suggestions: ${providerConfig.models.join(", ")}`).addText(
      (text) => text.setPlaceholder(providerConfig.defaultModel).setValue(this.plugin.settings.promptModel).onChange(async (value) => {
        this.plugin.settings.promptModel = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F5BC}\uFE0F Image Generation" });
    new import_obsidian.Setting(containerEl).setName("Image Model").setDesc("Google Gemini model for image generation. Must support image output.").addText(
      (text) => text.setPlaceholder("gemini-3-pro-image-preview").setValue(this.plugin.settings.imageModel).onChange(async (value) => {
        this.plugin.settings.imageModel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Image Style").setDesc("Default style for generated posters.").addDropdown(
      (dropdown) => dropdown.addOptions({
        "infographic": "\u{1F4CA} Infographic - Charts, icons, visual hierarchy",
        "poster": "\u{1F3A8} Poster - Bold typography, strong imagery",
        "diagram": "\u{1F4D0} Diagram - Technical, clear connections",
        "mindmap": "\u{1F9E0} Mind Map - Central concept with branches",
        "timeline": "\u{1F4C5} Timeline - Progression and milestones"
      }).setValue(this.plugin.settings.imageStyle).onChange(async (value) => {
        this.plugin.settings.imageStyle = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Preferred Language").setDesc("Language for text in generated images (e.g., titles, labels, descriptions).").addDropdown(
      (dropdown) => dropdown.addOptions({
        "ko": "\u{1F1F0}\u{1F1F7} \uD55C\uAD6D\uC5B4 (Korean)",
        "en": "\u{1F1FA}\u{1F1F8} English",
        "ja": "\u{1F1EF}\u{1F1F5} \u65E5\u672C\u8A9E (Japanese)",
        "zh": "\u{1F1E8}\u{1F1F3} \u4E2D\u6587 (Chinese)",
        "es": "\u{1F1EA}\u{1F1F8} Espa\xF1ol (Spanish)",
        "fr": "\u{1F1EB}\u{1F1F7} Fran\xE7ais (French)",
        "de": "\u{1F1E9}\u{1F1EA} Deutsch (German)"
      }).setValue(this.plugin.settings.preferredLanguage).onChange(async (value) => {
        this.plugin.settings.preferredLanguage = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u2699\uFE0F User Experience" });
    new import_obsidian.Setting(containerEl).setName("Show Preview Before Generation").setDesc("Show the generated prompt and allow editing before creating the image.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showPreviewBeforeGeneration).onChange(async (value) => {
        this.plugin.settings.showPreviewBeforeGeneration = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Progress Modal").setDesc("Display a progress indicator during generation.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showProgressModal).onChange(async (value) => {
        this.plugin.settings.showProgressModal = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Attachment Folder").setDesc("Folder to save generated images. Will be created if it doesn't exist.").addText(
      (text) => text.setPlaceholder("999-Attachments").setValue(this.plugin.settings.attachmentFolder).onChange(async (value) => {
        this.plugin.settings.attachmentFolder = value || "999-Attachments";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto-Retry Count").setDesc("Number of automatic retries on transient failures (0-5).").addSlider(
      (slider) => slider.setLimits(0, 5, 1).setValue(this.plugin.settings.autoRetryCount).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.autoRetryCount = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F527} Advanced" });
    new import_obsidian.Setting(containerEl).setName("Custom Prompt Prefix").setDesc("Optional text to prepend to all generated prompts.").addTextArea(
      (textarea) => textarea.setPlaceholder('e.g., "Create in a minimalist style with blue color scheme..."').setValue(this.plugin.settings.customPromptPrefix).onChange(async (value) => {
        this.plugin.settings.customPromptPrefix = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u2139\uFE0F About" });
    const aboutDiv = containerEl.createDiv({ cls: "nanobanana-about" });
    aboutDiv.createEl("p", {
      text: "NanoBanana PRO v1.0.0"
    });
    aboutDiv.createEl("p", {
      text: "Generate beautiful Knowledge Posters from your notes using AI."
    });
    const linksDiv = aboutDiv.createDiv({ cls: "nanobanana-links" });
    linksDiv.createEl("a", {
      text: "\u{1F4D6} Documentation",
      href: "https://github.com/username/nanobanana-pro-obsidian#readme"
    });
    linksDiv.createEl("span", { text: " | " });
    linksDiv.createEl("a", {
      text: "\u{1F41B} Report Issue",
      href: "https://github.com/username/nanobanana-pro-obsidian/issues"
    });
  }
};

// src/services/promptService.ts
var import_obsidian2 = require("obsidian");
var PromptService = class {
  /**
   * Generate an image prompt from note content using the specified AI provider
   */
  async generatePrompt(noteContent, provider, model, apiKey) {
    if (!apiKey) {
      throw this.createError("INVALID_API_KEY", `${PROVIDER_CONFIGS[provider].name} API key is not configured`);
    }
    if (!noteContent.trim()) {
      throw this.createError("NO_CONTENT", "Note content is empty");
    }
    try {
      const prompt = await this.callProvider(provider, model, apiKey, noteContent);
      return {
        prompt,
        model,
        provider
      };
    } catch (error) {
      if (error.type) {
        throw error;
      }
      throw this.handleApiError(error, provider);
    }
  }
  async callProvider(provider, model, apiKey, content) {
    switch (provider) {
      case "openai":
        return this.callOpenAI(model, apiKey, content);
      case "google":
        return this.callGoogle(model, apiKey, content);
      case "anthropic":
        return this.callAnthropic(model, apiKey, content);
      case "xai":
        return this.callXAI(model, apiKey, content);
      default:
        throw this.createError("UNKNOWN", `Unknown provider: ${provider}`);
    }
  }
  async callOpenAI(model, apiKey, content) {
    var _a, _b, _c;
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: "system", content: SYSTEM_PROMPT },
          { role: "user", content: `Create an image prompt for the following content:

${content}` }
        ],
        max_tokens: 1e3,
        temperature: 0.7
      })
    });
    if (response.status !== 200) {
      throw this.handleHttpError(response.status, response.text, "openai");
    }
    const data = response.json;
    return ((_c = (_b = (_a = data.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content) == null ? void 0 : _c.trim()) || "";
  }
  async callGoogle(model, apiKey, content) {
    var _a, _b, _c, _d, _e, _f;
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
    const response = await (0, import_obsidian2.requestUrl)({
      url,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `${SYSTEM_PROMPT}

Create an image prompt for the following content:

${content}`
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 1e3
        }
      })
    });
    if (response.status !== 200) {
      throw this.handleHttpError(response.status, response.text, "google");
    }
    const data = response.json;
    return ((_f = (_e = (_d = (_c = (_b = (_a = data.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.text) == null ? void 0 : _f.trim()) || "";
  }
  async callAnthropic(model, apiKey, content) {
    var _a, _b, _c;
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": apiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model,
        max_tokens: 1e3,
        system: SYSTEM_PROMPT,
        messages: [
          { role: "user", content: `Create an image prompt for the following content:

${content}` }
        ]
      })
    });
    if (response.status !== 200) {
      throw this.handleHttpError(response.status, response.text, "anthropic");
    }
    const data = response.json;
    return ((_c = (_b = (_a = data.content) == null ? void 0 : _a[0]) == null ? void 0 : _b.text) == null ? void 0 : _c.trim()) || "";
  }
  async callXAI(model, apiKey, content) {
    var _a, _b, _c;
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.x.ai/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: "system", content: SYSTEM_PROMPT },
          { role: "user", content: `Create an image prompt for the following content:

${content}` }
        ],
        max_tokens: 1e3,
        temperature: 0.7
      })
    });
    if (response.status !== 200) {
      throw this.handleHttpError(response.status, response.text, "xai");
    }
    const data = response.json;
    return ((_c = (_b = (_a = data.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content) == null ? void 0 : _c.trim()) || "";
  }
  handleHttpError(status, responseText, provider) {
    if (status === 401 || status === 403) {
      return this.createError("INVALID_API_KEY", `Invalid ${PROVIDER_CONFIGS[provider].name} API key`);
    }
    if (status === 429) {
      return this.createError("RATE_LIMIT", "API rate limit exceeded. Please wait and try again.", true);
    }
    if (status >= 500) {
      return this.createError("NETWORK_ERROR", "Server error. Please try again later.", true);
    }
    return this.createError("GENERATION_FAILED", `API error: ${responseText}`);
  }
  handleApiError(error, provider) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("net::") || errorMessage.includes("network")) {
      return this.createError("NETWORK_ERROR", "Network connection error. Check your internet connection.", true);
    }
    return this.createError("GENERATION_FAILED", `${PROVIDER_CONFIGS[provider].name} error: ${errorMessage}`);
  }
  createError(type, message, retryable = false) {
    return { type, message, retryable };
  }
};

// src/services/imageService.ts
var import_obsidian3 = require("obsidian");
var ImageService = class {
  /**
   * Generate an infographic image using Google Gemini
   */
  async generateImage(prompt, apiKey, model, style, preferredLanguage) {
    if (!apiKey) {
      throw this.createError("INVALID_API_KEY", "Google API key is not configured");
    }
    if (!prompt.trim()) {
      throw this.createError("NO_CONTENT", "Prompt is empty");
    }
    try {
      const languageInstructions = {
        ko: "IMPORTANT: All text in the image MUST be in Korean (\uD55C\uAD6D\uC5B4). Titles, labels, descriptions, and all content should be written in Korean.",
        en: "IMPORTANT: All text in the image MUST be in English. Titles, labels, descriptions, and all content should be written in English.",
        ja: "IMPORTANT: All text in the image MUST be in Japanese (\u65E5\u672C\u8A9E). Titles, labels, descriptions, and all content should be written in Japanese.",
        zh: "IMPORTANT: All text in the image MUST be in Chinese (\u4E2D\u6587). Titles, labels, descriptions, and all content should be written in Chinese.",
        es: "IMPORTANT: All text in the image MUST be in Spanish (Espa\xF1ol). Titles, labels, descriptions, and all content should be written in Spanish.",
        fr: "IMPORTANT: All text in the image MUST be in French (Fran\xE7ais). Titles, labels, descriptions, and all content should be written in French.",
        de: "IMPORTANT: All text in the image MUST be in German (Deutsch). Titles, labels, descriptions, and all content should be written in German."
      };
      const fullPrompt = IMAGE_GENERATION_PROMPT_TEMPLATE.replace("{style}", IMAGE_STYLES[style]).replace("{prompt}", prompt) + "\n\n" + languageInstructions[preferredLanguage];
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      const response = await (0, import_obsidian3.requestUrl)({
        url,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: fullPrompt
            }]
          }],
          generationConfig: {
            responseModalities: ["TEXT", "IMAGE"]
          }
        })
      });
      if (response.status !== 200) {
        throw this.handleHttpError(response.status, response.text);
      }
      const data = response.json;
      const imageData = this.extractImageFromResponse(data);
      if (!imageData) {
        throw this.createError("GENERATION_FAILED", "No image was generated. Try a different prompt or style.");
      }
      return {
        imageData: imageData.data,
        mimeType: imageData.mimeType,
        model
      };
    } catch (error) {
      if (error.type) {
        throw error;
      }
      throw this.handleApiError(error);
    }
  }
  /**
   * Extract base64 image data from Gemini API response
   */
  extractImageFromResponse(data) {
    var _a;
    try {
      const candidates = data.candidates;
      if (!candidates || candidates.length === 0) {
        return null;
      }
      const content = candidates[0].content;
      if (!content || !content.parts) {
        return null;
      }
      for (const part of content.parts) {
        if (part.inline_data) {
          return {
            data: part.inline_data.data,
            mimeType: part.inline_data.mime_type || "image/png"
          };
        }
      }
      if ((_a = content.parts[0]) == null ? void 0 : _a.inlineData) {
        return {
          data: content.parts[0].inlineData.data,
          mimeType: content.parts[0].inlineData.mimeType || "image/png"
        };
      }
      return null;
    } catch (e) {
      console.error("Error extracting image from response:", e);
      return null;
    }
  }
  handleHttpError(status, responseText) {
    if (status === 401 || status === 403) {
      return this.createError("INVALID_API_KEY", "Invalid Google API key");
    }
    if (status === 429) {
      return this.createError("RATE_LIMIT", "API rate limit exceeded. Please wait and try again.", true);
    }
    if (status === 400) {
      if (responseText.includes("SAFETY") || responseText.includes("blocked")) {
        return this.createError("CONTENT_FILTERED", "Content was blocked by safety filters. Try modifying your prompt.");
      }
      return this.createError("GENERATION_FAILED", `Bad request: ${responseText}`);
    }
    if (status >= 500) {
      return this.createError("NETWORK_ERROR", "Server error. Please try again later.", true);
    }
    return this.createError("GENERATION_FAILED", `API error (${status}): ${responseText}`);
  }
  handleApiError(error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("net::") || errorMessage.includes("network")) {
      return this.createError("NETWORK_ERROR", "Network connection error. Check your internet connection.", true);
    }
    return this.createError("GENERATION_FAILED", `Image generation error: ${errorMessage}`);
  }
  createError(type, message, retryable = false) {
    return { type, message, retryable };
  }
};

// src/services/fileService.ts
var import_obsidian4 = require("obsidian");
var FileService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Save image to the vault and return the path
   */
  async saveImage(imageData, mimeType, noteFile, attachmentFolder) {
    try {
      const extension = this.getExtensionFromMimeType(mimeType);
      const timestamp = Date.now();
      const baseName = noteFile.basename.replace(/[^a-zA-Z0-9가-힣]/g, "-");
      const fileName = `${baseName}-poster-${timestamp}.${extension}`;
      await this.ensureFolderExists(attachmentFolder);
      const imagePath = (0, import_obsidian4.normalizePath)(`${attachmentFolder}/${fileName}`);
      const binaryData = this.base64ToArrayBuffer(imageData);
      await this.app.vault.createBinary(imagePath, binaryData);
      return imagePath;
    } catch (error) {
      throw this.createError("SAVE_ERROR", `Failed to save image: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Embed image at the top of the note
   */
  async embedImageInNote(noteFile, imagePath) {
    try {
      const content = await this.app.vault.read(noteFile);
      const embedSyntax = `![[${imagePath}]]

`;
      const frontmatterMatch = content.match(/^---\n[\s\S]*?\n---\n/);
      let newContent;
      if (frontmatterMatch) {
        const frontmatter = frontmatterMatch[0];
        const restContent = content.slice(frontmatter.length);
        const existingEmbed = restContent.match(/^!\[\[.*-poster-\d+\.(png|jpg|jpeg|webp)\]\]\n\n/);
        if (existingEmbed) {
          newContent = frontmatter + embedSyntax + restContent.slice(existingEmbed[0].length);
        } else {
          newContent = frontmatter + embedSyntax + restContent;
        }
      } else {
        const existingEmbed = content.match(/^!\[\[.*-poster-\d+\.(png|jpg|jpeg|webp)\]\]\n\n/);
        if (existingEmbed) {
          newContent = embedSyntax + content.slice(existingEmbed[0].length);
        } else {
          newContent = embedSyntax + content;
        }
      }
      await this.app.vault.modify(noteFile, newContent);
    } catch (error) {
      throw this.createError("SAVE_ERROR", `Failed to embed image: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Ensure a folder exists, creating it if necessary
   */
  async ensureFolderExists(folderPath) {
    const normalizedPath = (0, import_obsidian4.normalizePath)(folderPath);
    const folder = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (!folder) {
      await this.app.vault.createFolder(normalizedPath);
    } else if (!(folder instanceof import_obsidian4.TFolder)) {
      throw this.createError("SAVE_ERROR", `${folderPath} exists but is not a folder`);
    }
  }
  /**
   * Convert base64 string to ArrayBuffer
   */
  base64ToArrayBuffer(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
  }
  /**
   * Get file extension from MIME type
   */
  getExtensionFromMimeType(mimeType) {
    const mimeMap = {
      "image/png": "png",
      "image/jpeg": "jpg",
      "image/jpg": "jpg",
      "image/webp": "webp",
      "image/gif": "gif"
    };
    return mimeMap[mimeType] || "png";
  }
  createError(type, message) {
    return { type, message, retryable: false };
  }
};

// src/progressModal.ts
var import_obsidian5 = require("obsidian");
var ProgressModal = class extends import_obsidian5.Modal {
  constructor(app) {
    super(app);
    this.onCancel = null;
    this.isCancelled = false;
    this.steps = [
      { key: "analyzing", label: "\uB178\uD2B8 \uBD84\uC11D", icon: "\u{1F4C4}" },
      { key: "generating-prompt", label: "\uD504\uB86C\uD504\uD2B8 \uC0DD\uC131", icon: "\u{1F916}" },
      { key: "generating-image", label: "\uC774\uBBF8\uC9C0 \uC0DD\uC131", icon: "\u{1F3A8}" },
      { key: "saving", label: "\uD30C\uC77C \uC800\uC7A5", icon: "\u{1F4BE}" },
      { key: "embedding", label: "\uB178\uD2B8\uC5D0 \uC0BD\uC785", icon: "\u{1F4CE}" }
    ];
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("nanobanana-progress-modal");
    contentEl.createEl("h2", {
      text: "\u{1F3A8} Knowledge Poster \uC0DD\uC131 \uC911...",
      cls: "nanobanana-progress-title"
    });
    this.progressContainer = contentEl.createDiv({ cls: "nanobanana-progress-container" });
    this.progressBar = this.progressContainer.createDiv({ cls: "nanobanana-progress-bar" });
    this.progressText = this.progressContainer.createDiv({
      cls: "nanobanana-progress-text",
      text: "0%"
    });
    this.stepsContainer = contentEl.createDiv({ cls: "nanobanana-steps-container" });
    this.renderSteps();
    contentEl.createDiv({
      cls: "nanobanana-estimated-time",
      text: "\u23F1\uFE0F \uC608\uC0C1 \uC18C\uC694 \uC2DC\uAC04: \uC57D 15-30\uCD08"
    });
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    this.cancelButton = buttonContainer.createEl("button", {
      text: "\uCDE8\uC18C",
      cls: "nanobanana-cancel-button"
    });
    this.cancelButton.addEventListener("click", () => {
      this.isCancelled = true;
      if (this.onCancel) {
        this.onCancel();
      }
      this.close();
    });
  }
  renderSteps() {
    this.stepsContainer.empty();
    for (const step of this.steps) {
      const stepEl = this.stepsContainer.createDiv({ cls: "nanobanana-step" });
      stepEl.createSpan({ cls: "nanobanana-step-icon", text: "\u23F3" });
      stepEl.createSpan({ cls: "nanobanana-step-label", text: `${step.icon} ${step.label}` });
      stepEl.dataset.step = step.key;
    }
  }
  updateProgress(state) {
    if (this.isCancelled)
      return;
    this.progressBar.style.width = `${state.progress}%`;
    this.progressText.setText(`${Math.round(state.progress)}%`);
    const stepIndex = this.steps.findIndex((s) => s.key === state.step);
    const stepElements = this.stepsContainer.querySelectorAll(".nanobanana-step");
    stepElements.forEach((el, index) => {
      const iconEl = el.querySelector(".nanobanana-step-icon");
      if (!iconEl)
        return;
      if (index < stepIndex) {
        el.addClass("completed");
        el.removeClass("active");
        iconEl.setText("\u2705");
      } else if (index === stepIndex) {
        el.addClass("active");
        el.removeClass("completed");
        iconEl.setText("\u{1F504}");
      } else {
        el.removeClass("active", "completed");
        iconEl.setText("\u23F3");
      }
    });
  }
  showError(error) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("nanobanana-error-state");
    contentEl.createEl("h2", {
      text: "\u274C \uC0DD\uC131 \uC2E4\uD328",
      cls: "nanobanana-error-title"
    });
    const errorBox = contentEl.createDiv({ cls: "nanobanana-error-box" });
    errorBox.createEl("p", { text: error.message });
    if (error.details) {
      errorBox.createEl("p", {
        text: error.details,
        cls: "nanobanana-error-details"
      });
    }
    const suggestions = this.getErrorSuggestions(error);
    if (suggestions.length > 0) {
      const suggestionBox = contentEl.createDiv({ cls: "nanobanana-suggestions" });
      suggestionBox.createEl("p", { text: "\u{1F4A1} \uD574\uACB0 \uBC29\uBC95:" });
      const list = suggestionBox.createEl("ul");
      for (const suggestion of suggestions) {
        list.createEl("li", { text: suggestion });
      }
    }
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    if (error.retryable) {
      const retryButton = buttonContainer.createEl("button", {
        text: "\uB2E4\uC2DC \uC2DC\uB3C4",
        cls: "nanobanana-retry-button mod-cta"
      });
      retryButton.addEventListener("click", () => {
        if (this.onCancel) {
          this.close();
        }
      });
    }
    const closeButton = buttonContainer.createEl("button", {
      text: "\uB2EB\uAE30",
      cls: "nanobanana-close-button"
    });
    closeButton.addEventListener("click", () => this.close());
  }
  showSuccess(imagePath) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("nanobanana-success-state");
    contentEl.createEl("h2", {
      text: "\u2705 Knowledge Poster \uC0DD\uC131 \uC644\uB8CC!",
      cls: "nanobanana-success-title"
    });
    const infoBox = contentEl.createDiv({ cls: "nanobanana-success-box" });
    infoBox.createEl("p", { text: `\u{1F4C1} \uC800\uC7A5 \uC704\uCE58: ${imagePath}` });
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    const closeButton = buttonContainer.createEl("button", {
      text: "\uD655\uC778",
      cls: "nanobanana-close-button mod-cta"
    });
    closeButton.addEventListener("click", () => this.close());
    setTimeout(() => {
      if (!this.isCancelled) {
        this.close();
      }
    }, 3e3);
  }
  getErrorSuggestions(error) {
    switch (error.type) {
      case "INVALID_API_KEY":
        return [
          "\uC124\uC815\uC5D0\uC11C API \uD0A4\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694",
          "API \uD0A4\uAC00 \uC62C\uBC14\uB974\uAC8C \uC785\uB825\uB418\uC5C8\uB294\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694",
          "\uD574\uB2F9 \uC11C\uBE44\uC2A4\uC758 API \uD0A4\uAC00 \uD65C\uC131\uD654\uB418\uC5B4 \uC788\uB294\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694"
        ];
      case "RATE_LIMIT":
        return [
          "\uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694",
          "API \uC0AC\uC6A9\uB7C9 \uD55C\uB3C4\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694"
        ];
      case "NETWORK_ERROR":
        return [
          "\uC778\uD130\uB137 \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694",
          "VPN\uC774\uB098 \uD504\uB85D\uC2DC \uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694"
        ];
      case "GENERATION_FAILED":
        return [
          "\uB2E4\uB978 \uC2A4\uD0C0\uC77C\uB85C \uC2DC\uB3C4\uD574\uBCF4\uC138\uC694",
          "\uB178\uD2B8 \uB0B4\uC6A9\uC744 \uC218\uC815\uD558\uACE0 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694"
        ];
      case "CONTENT_FILTERED":
        return [
          "\uB178\uD2B8 \uB0B4\uC6A9\uC744 \uC218\uC815\uD574\uC8FC\uC138\uC694",
          "\uBBFC\uAC10\uD55C \uB0B4\uC6A9\uC774 \uD3EC\uD568\uB418\uC5B4 \uC788\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4"
        ];
      case "NO_CONTENT":
        return [
          "\uB178\uD2B8\uC5D0 \uB0B4\uC6A9\uC744 \uCD94\uAC00\uD574\uC8FC\uC138\uC694"
        ];
      default:
        return [];
    }
  }
  setOnCancel(callback) {
    this.onCancel = callback;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/previewModal.ts
var import_obsidian6 = require("obsidian");
var PreviewModal = class extends import_obsidian6.Modal {
  constructor(app, prompt, settings, onConfirm) {
    super(app);
    this.prompt = prompt;
    this.settings = settings;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("nanobanana-preview-modal");
    contentEl.createEl("h2", {
      text: "\u{1F4DD} \uD504\uB86C\uD504\uD2B8 \uBBF8\uB9AC\uBCF4\uAE30",
      cls: "nanobanana-preview-title"
    });
    const infoSection = contentEl.createDiv({ cls: "nanobanana-preview-info" });
    infoSection.createDiv({
      cls: "nanobanana-preview-info-item",
      text: `\u{1F916} \uD504\uB86C\uD504\uD2B8 \uBAA8\uB378: ${PROVIDER_CONFIGS[this.settings.selectedProvider].name} - ${this.settings.promptModel}`
    });
    infoSection.createDiv({
      cls: "nanobanana-preview-info-item",
      text: `\u{1F5BC}\uFE0F \uC774\uBBF8\uC9C0 \uBAA8\uB378: ${this.settings.imageModel}`
    });
    infoSection.createDiv({
      cls: "nanobanana-preview-info-item",
      text: `\u{1F4CA} \uC2A4\uD0C0\uC77C: ${IMAGE_STYLES[this.settings.imageStyle]}`
    });
    const textareaContainer = contentEl.createDiv({ cls: "nanobanana-textarea-container" });
    textareaContainer.createEl("label", {
      text: "\uC0DD\uC131\uB41C \uD504\uB86C\uD504\uD2B8 (\uC218\uC815 \uAC00\uB2A5):",
      cls: "nanobanana-textarea-label"
    });
    this.promptTextarea = textareaContainer.createEl("textarea", {
      cls: "nanobanana-prompt-textarea"
    });
    this.promptTextarea.value = this.prompt;
    this.promptTextarea.rows = 10;
    const charCount = textareaContainer.createDiv({ cls: "nanobanana-char-count" });
    charCount.setText(`${this.prompt.length} \uC790`);
    this.promptTextarea.addEventListener("input", () => {
      charCount.setText(`${this.promptTextarea.value.length} \uC790`);
    });
    const tipsSection = contentEl.createDiv({ cls: "nanobanana-tips" });
    tipsSection.createEl("p", { text: "\u{1F4A1} \uD301:" });
    const tipsList = tipsSection.createEl("ul");
    tipsList.createEl("li", { text: "\uD504\uB86C\uD504\uD2B8\uB97C \uC218\uC815\uD558\uC5EC \uC6D0\uD558\uB294 \uC2A4\uD0C0\uC77C\uB85C \uC870\uC815\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4" });
    tipsList.createEl("li", { text: "\uAD6C\uCCB4\uC801\uC778 \uC0C9\uC0C1, \uB808\uC774\uC544\uC6C3, \uC694\uC18C\uB97C \uCD94\uAC00\uD558\uBA74 \uB354 \uC88B\uC740 \uACB0\uACFC\uB97C \uC5BB\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4" });
    tipsList.createEl("li", { text: '"\uB2E4\uC2DC \uC0DD\uC131" \uBC84\uD2BC\uC73C\uB85C \uC0C8\uB85C\uC6B4 \uD504\uB86C\uD504\uD2B8\uB97C \uC0DD\uC131\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4' });
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    const generateButton = buttonContainer.createEl("button", {
      text: "\u{1F3A8} \uC774\uBBF8\uC9C0 \uC0DD\uC131",
      cls: "mod-cta"
    });
    generateButton.addEventListener("click", () => {
      this.onConfirm({
        confirmed: true,
        prompt: this.promptTextarea.value,
        regenerate: false
      });
      this.close();
    });
    const regenerateButton = buttonContainer.createEl("button", {
      text: "\u{1F504} \uB2E4\uC2DC \uC0DD\uC131"
    });
    regenerateButton.addEventListener("click", () => {
      this.onConfirm({
        confirmed: true,
        prompt: "",
        regenerate: true
      });
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "\uCDE8\uC18C"
    });
    cancelButton.addEventListener("click", () => {
      this.onConfirm({
        confirmed: false,
        prompt: "",
        regenerate: false
      });
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var NanoBananaPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.lastPrompt = "";
    this.lastNoteFile = null;
    this.isGenerating = false;
  }
  async onload() {
    await this.loadSettings();
    this.promptService = new PromptService();
    this.imageService = new ImageService();
    this.fileService = new FileService(this.app);
    this.addCommand({
      id: "generate-knowledge-poster",
      name: "Generate Knowledge Poster",
      callback: () => this.generatePoster()
    });
    this.addCommand({
      id: "generate-prompt-only",
      name: "Generate Prompt Only (Copy to Clipboard)",
      callback: () => this.generatePromptOnly()
    });
    this.addCommand({
      id: "regenerate-last-poster",
      name: "Regenerate Last Poster",
      callback: () => this.regenerateLastPoster()
    });
    this.addSettingTab(new NanoBananaSettingTab(this.app, this));
    console.log("NanoBanana PRO loaded");
  }
  onunload() {
    console.log("NanoBanana PRO unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Main generation flow
   */
  async generatePoster() {
    if (this.isGenerating) {
      new import_obsidian7.Notice("Generation already in progress");
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
    if (!activeView || !activeView.file) {
      new import_obsidian7.Notice("Please open a note first");
      return;
    }
    const noteFile = activeView.file;
    const noteContent = await this.app.vault.read(noteFile);
    if (!noteContent.trim()) {
      new import_obsidian7.Notice("Note is empty. Please add some content first.");
      return;
    }
    if (!this.settings.googleApiKey) {
      new import_obsidian7.Notice("Google API key is required for image generation. Please configure it in settings.");
      return;
    }
    const providerKey = this.getProviderApiKey();
    if (!providerKey) {
      new import_obsidian7.Notice(`${this.settings.selectedProvider} API key is not configured. Please check settings.`);
      return;
    }
    this.isGenerating = true;
    this.lastNoteFile = noteFile;
    let progressModal = null;
    try {
      if (this.settings.showProgressModal) {
        progressModal = new ProgressModal(this.app);
        progressModal.open();
      }
      this.updateProgress(progressModal, {
        step: "generating-prompt",
        progress: 20,
        message: "\uD504\uB86C\uD504\uD2B8 \uC0DD\uC131 \uC911..."
      });
      const promptResult = await this.executeWithRetry(async () => {
        return await this.promptService.generatePrompt(
          noteContent,
          this.settings.selectedProvider,
          this.settings.promptModel,
          providerKey
        );
      });
      let finalPrompt = promptResult.prompt;
      this.lastPrompt = finalPrompt;
      if (this.settings.customPromptPrefix) {
        finalPrompt = `${this.settings.customPromptPrefix}

${finalPrompt}`;
      }
      if (this.settings.showPreviewBeforeGeneration) {
        if (progressModal) {
          progressModal.close();
          progressModal = null;
        }
        const previewResult = await this.showPreviewModal(finalPrompt);
        if (!previewResult.confirmed) {
          this.isGenerating = false;
          return;
        }
        if (previewResult.regenerate) {
          this.isGenerating = false;
          return this.generatePoster();
        }
        finalPrompt = previewResult.prompt;
        if (this.settings.showProgressModal) {
          progressModal = new ProgressModal(this.app);
          progressModal.open();
        }
      }
      this.updateProgress(progressModal, {
        step: "generating-image",
        progress: 50,
        message: "\uC774\uBBF8\uC9C0 \uC0DD\uC131 \uC911..."
      });
      const imageResult = await this.executeWithRetry(async () => {
        return await this.imageService.generateImage(
          finalPrompt,
          this.settings.googleApiKey,
          this.settings.imageModel,
          this.settings.imageStyle,
          this.settings.preferredLanguage
        );
      });
      this.updateProgress(progressModal, {
        step: "saving",
        progress: 80,
        message: "\uD30C\uC77C \uC800\uC7A5 \uC911..."
      });
      const imagePath = await this.fileService.saveImage(
        imageResult.imageData,
        imageResult.mimeType,
        noteFile,
        this.settings.attachmentFolder
      );
      this.updateProgress(progressModal, {
        step: "embedding",
        progress: 95,
        message: "\uB178\uD2B8\uC5D0 \uC0BD\uC785 \uC911..."
      });
      await this.fileService.embedImageInNote(noteFile, imagePath);
      this.updateProgress(progressModal, {
        step: "complete",
        progress: 100,
        message: "\uC644\uB8CC!"
      });
      if (progressModal) {
        progressModal.showSuccess(imagePath);
      } else {
        new import_obsidian7.Notice("\u2705 Knowledge Poster generated successfully!");
      }
    } catch (error) {
      const genError = error;
      if (progressModal) {
        progressModal.showError(genError);
      } else {
        new import_obsidian7.Notice(`\u274C Generation failed: ${genError.message}`);
      }
      console.error("NanoBanana PRO error:", error);
    } finally {
      this.isGenerating = false;
    }
  }
  /**
   * Generate prompt only and copy to clipboard
   */
  async generatePromptOnly() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
    if (!activeView || !activeView.file) {
      new import_obsidian7.Notice("Please open a note first");
      return;
    }
    const noteContent = await this.app.vault.read(activeView.file);
    if (!noteContent.trim()) {
      new import_obsidian7.Notice("Note is empty");
      return;
    }
    const providerKey = this.getProviderApiKey();
    if (!providerKey) {
      new import_obsidian7.Notice(`${this.settings.selectedProvider} API key is not configured`);
      return;
    }
    try {
      new import_obsidian7.Notice("Generating prompt...");
      const result = await this.promptService.generatePrompt(
        noteContent,
        this.settings.selectedProvider,
        this.settings.promptModel,
        providerKey
      );
      await navigator.clipboard.writeText(result.prompt);
      this.lastPrompt = result.prompt;
      new import_obsidian7.Notice("\u2705 Prompt copied to clipboard!");
    } catch (error) {
      const genError = error;
      new import_obsidian7.Notice(`\u274C Failed: ${genError.message}`);
    }
  }
  /**
   * Regenerate using the last prompt
   */
  async regenerateLastPoster() {
    if (!this.lastPrompt) {
      new import_obsidian7.Notice("No previous generation found. Please generate a poster first.");
      return;
    }
    if (!this.lastNoteFile) {
      new import_obsidian7.Notice("Original note not found. Please generate a new poster.");
      return;
    }
    const file = this.app.vault.getAbstractFileByPath(this.lastNoteFile.path);
    if (!file || !(file instanceof import_obsidian7.TFile)) {
      new import_obsidian7.Notice("Original note was moved or deleted");
      return;
    }
    if (this.isGenerating) {
      new import_obsidian7.Notice("Generation already in progress");
      return;
    }
    this.isGenerating = true;
    let progressModal = null;
    try {
      if (this.settings.showProgressModal) {
        progressModal = new ProgressModal(this.app);
        progressModal.open();
      }
      this.updateProgress(progressModal, {
        step: "generating-image",
        progress: 40,
        message: "\uC774\uBBF8\uC9C0 \uC0DD\uC131 \uC911..."
      });
      const imageResult = await this.executeWithRetry(async () => {
        return await this.imageService.generateImage(
          this.lastPrompt,
          this.settings.googleApiKey,
          this.settings.imageModel,
          this.settings.imageStyle,
          this.settings.preferredLanguage
        );
      });
      this.updateProgress(progressModal, {
        step: "saving",
        progress: 80,
        message: "\uD30C\uC77C \uC800\uC7A5 \uC911..."
      });
      const imagePath = await this.fileService.saveImage(
        imageResult.imageData,
        imageResult.mimeType,
        this.lastNoteFile,
        this.settings.attachmentFolder
      );
      this.updateProgress(progressModal, {
        step: "embedding",
        progress: 95,
        message: "\uB178\uD2B8\uC5D0 \uC0BD\uC785 \uC911..."
      });
      await this.fileService.embedImageInNote(this.lastNoteFile, imagePath);
      if (progressModal) {
        progressModal.showSuccess(imagePath);
      } else {
        new import_obsidian7.Notice("\u2705 Poster regenerated successfully!");
      }
    } catch (error) {
      const genError = error;
      if (progressModal) {
        progressModal.showError(genError);
      } else {
        new import_obsidian7.Notice(`\u274C Regeneration failed: ${genError.message}`);
      }
    } finally {
      this.isGenerating = false;
    }
  }
  /**
   * Show preview modal and wait for user decision
   */
  showPreviewModal(prompt) {
    return new Promise((resolve) => {
      const modal = new PreviewModal(
        this.app,
        prompt,
        this.settings,
        (result) => resolve(result)
      );
      modal.open();
    });
  }
  /**
   * Execute operation with auto-retry
   */
  async executeWithRetry(operation) {
    let lastError = null;
    for (let attempt = 0; attempt <= this.settings.autoRetryCount; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (!lastError.retryable || attempt === this.settings.autoRetryCount) {
          throw lastError;
        }
        const delay = Math.pow(2, attempt) * 1e3;
        await this.sleep(delay);
      }
    }
    throw lastError;
  }
  /**
   * Update progress modal
   */
  updateProgress(modal, state) {
    if (modal) {
      modal.updateProgress(state);
    }
  }
  /**
   * Get API key for the selected provider
   */
  getProviderApiKey() {
    switch (this.settings.selectedProvider) {
      case "openai":
        return this.settings.openaiApiKey;
      case "google":
        return this.settings.googleApiKey;
      case "anthropic":
        return this.settings.anthropicApiKey;
      case "xai":
        return this.settings.xaiApiKey;
      default:
        return "";
    }
  }
  /**
   * Sleep utility
   */
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
};
